<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * @author Baptiste Mazin     &lt;baptiste.mazin@telecom-paristech.fr&gt;
 * @author Guillaume Tartavel &lt;guillaume.tartavel@telecom-paristech.fr&gt;
 */

(function (Matrix, Matrix_prototype) {
    &#39;use strict&#39;;
    
<span id='Matrix'>    /** @class Matrix */
</span>    var filter1DPad = function (y0, o, oys, ny, dy, ody, orig, K, kdy, ly, isOdd, kernelL, kernelH, idL, idH, odL, odH) {
        var y, oy, k, s, sumL, sumH;
        y0 += (K - 1) * kdy - orig;
        ny -= orig;
        for (y = y0, oy = o + oys; y &lt; ny; y += dy, oy += ody) {
            for (k = 0, s = y + orig, sumL = 0, sumH = 0; k &lt; K; k++, s -= kdy) {
                sumL += kernelL[k] * idL[s];
                sumH += kernelH[k] * idH[s];
            }
            odL[oy] += sumL;
            odH[oy] += sumH;
        }
    };
    var filter1DPadMono = function (y0, o, oys, ny, dy, ody, orig, K, kdy, ly, isOdd, kernel, id, od) {
        var y, oy, k, s, sum;
        y0 += (K - 1) * kdy - orig;
        ny -= orig;
        for (y = y0, oy = o + oys; y &lt; ny; y += dy, oy += ody) {
            for (k = 0, s = y + orig, sum = 0; k &lt; K; k++, s -= kdy) {
                sum += kernel[k] * id[s];
            }
            od[oy] += sum;
        }
    };

    var filter1DPadDebug = function (y0, o, oys, ny, dy, ody, orig, K, kdy, ly, isOdd, kernelL, kernelH, idL, idH, odL, odH) {
        var y, oy, k, s, sumL, sumH;
        console.log(&quot;y0&quot;, y0, &quot;ny&quot;, ny, &quot;dy&quot;, dy, &quot;oys&quot;, oys, &quot;ody&quot;, ody);
        console.log(&quot;orig&quot;, orig, &quot;K&quot;, K, &quot;Kdy&quot;, kdy);
        y0 += (K - 1) * kdy - orig;
        ny -= orig;// + (isOdd ? 1 : 0)
        console.log(&quot;y0&quot;, y0, &quot;ny&quot;, ny, orig);
        for (y = y0, oy = o + oys; y &lt; ny; y += dy, oy += ody) {
            var sig = [], fil = [], valL = [], valk = [];
            for (k = 0, s = y + orig, sumL = 0, sumH = 0; k &lt; K; k++, s -= kdy) {
                sig.push(s);
                fil.push(k);
                valL.push(idL[s]);
                valk.push(kernelL[k]);
                sumL += kernelL[k] * idL[s];
                sumH += kernelH[k] * idH[s];
            }
            console.log(&quot;y =&quot;, y, &quot;oy =&quot;, oy, sig);
            // console.log(oy, valL, y, ny);
            // console.log(oy, valk, y, ny);
            // console.log(sumL, sumH, sumH + sumL);
            odL[oy] += sumL;
            odH[oy] += sumH;
        }
        console.log(&quot;&quot;);
    };
    var filter1DPadCheck = function (y0, o, oys, ny, dy, ody, orig, K, kdy, ly, isOdd, kernelL, kernelH, idL, idH, odL, odH) {
        var y, oy, k, s, sumL, sumH;
        y0 += (K - 1) * kdy - orig;
        ny -= orig;
        if (odL.length !== odH.length) {
            throw new Error(&quot;Output length error&quot;);
        }
        if (idL.length !== idH.length) {
            throw new Error(&quot;input length error&quot;);
        }
        for (y = y0, oy = o + oys; y &lt; ny; y += dy, oy += ody) {
            for (k = 0, s = y + orig, sumL = 0, sumH = 0; k &lt; K; k++, s -= kdy) {
                if (k &lt; 0 || k &gt;= kernelL.length) {
                    throw new Error(&quot;Kernel error&quot;);
                }
                if (s &lt; 0 || s &gt;= idL.length) {
                    throw new Error(&quot;Input error&quot;);
                }
                sumL += kernelL[k] * idL[s];
                sumH += kernelH[k] * idH[s];
            }
            if (oy &lt; 0 || oy &gt;= odL.length) {
                throw new Error(&quot;Output error&quot;);
            }
            odL[oy] += sumL;
            odH[oy] += sumH;
        }
    };
    var filter1DPadMonoCheck = function (y0, o, oys, ny, dy, ody, orig, K, kdy, ly, isOdd, kernel, id, od) {
        var y, oy, k, s, sum;
        y0 += (K - 1) * kdy - orig;
        ny -= orig;
        for (y = y0, oy = o + oys; y &lt; ny; y += dy, oy += ody) {
            for (k = 0, s = y + orig, sum = 0; k &lt; K; k++, s -= kdy) {
                if (k &lt; 0 || k &gt;= kernel.length) {
                    throw new Error(&quot;Kernel error&quot;);
                }
                if (s &lt; 0 || s &gt;= id.length) {
                    throw new Error(&quot;Input error&quot;);
                }
                sum += kernel[k] * id[s];
            }
            if (oy &lt; 0 || oy &gt;= od.length) {
                throw new Error(&quot;Output error&quot;);
            }
            od[oy] += sum;
        }
    };
    var filter1D, filter1DMono, dwtmode;
    
<span id='Matrix-method-dwtmode'>    /** Select or return the mode used for bordering management.
</span>     *   Available modes are :
     *   - &quot;per&quot;, for periodic, it leads to the shortest representation,
     *   - &quot;sym&quot;, for symmetric boundary (default mode),
     *   - &quot;nn&quot;, for nearest neighbour boundary,
     *   - &quot;symw&quot;, for symmetric boundary with whole point,
     *   - &quot;zpd&quot;. zero padding boundary.
     *
     *  @param {string} mode
     *   The mode to be used.
     *  @return {String} 
     *   Returns the current or new mode.
     */
    Matrix.dwtmode = function (mode) {
        if (mode === undefined) {
            return dwtmode;
        }
        mode = mode.toLowerCase();
        switch (mode) {
        case &quot;per&quot;:
        case &quot;sym&quot;:
        case &quot;symw&quot;:
        case &quot;zpd&quot;:
        case &quot;nn&quot;:
            filter1D = filter1DPad;
            filter1DMono = filter1DPadMono;
            break;
        case &quot;debug_sym&quot;:
        case &quot;debug_symw&quot;:
        case &quot;debug_zpd&quot;:
        case &quot;debug_nn&quot;:
            mode = mode.substr(6);
            filter1D = filter1DPadDebug;
            break;
        case &quot;check_sym&quot;:
        case &quot;check_symw&quot;:
        case &quot;check_zpd&quot;:
        case &quot;check_nn&quot;:
        case &quot;check_per&quot;:
            mode = mode.substr(6);
            filter1D = filter1DPadCheck;
            filter1DMono = filter1DPadMonoCheck;
            break;
        default:
            throw new Error(&quot;Matrix.dwtmode: invalid mode &quot; + mode + &quot;.&quot;); 
        }
        dwtmode = mode;
        return dwtmode;
    };
    Matrix.dwtmode(&quot;sym&quot;);

    var filterND = function (inL, inH, vI, name, forward, origin, sub, outL, outH, vO) {
        var wav = Matrix.wfilters(name, forward ? &#39;d&#39; : &#39;r&#39;);
        var kL = wav[0].getData(), kH = wav[1].getData(), K = kL.length;
        
        origin = (origin === &#39;cl&#39; ? Math.floor : Math.ceil)((K - 1) / 2);
        var isOdd = vI.getSize(0) % 2 ? true : false; 
     
        var ys = vI.getFirst(0), dy = vI.getStep(0);
        var ly = vI.getEnd(0);
        var oys = vO.getFirst(0), ody = vO.getStep(0);

        var orig = origin * dy;
        var kdy = dy;
        dy *= sub;

        var itI = vI.getIterator(1), itO = vO.getIterator(1);
        var y, i, it = itI.iterator, bi = itI.begin, ei = itI.end();
        var oy, o, ot = itO.iterator, bo = itO.begin;

        var s, sTmp, sumL, sumH;
        var yx0, nyx;
        if (!inL || !inH) {
            var id = (inL || inH).getData(), 
                od = (inL ? outL : outH).getData(),
                k = inL ? kL : kH;
            for (i = bi(), o = bo(); i !== ei; i = it(), o = ot()) {
                yx0 = ys + i;
                nyx = ly + i;
                filter1DMono(yx0, o, oys, nyx, dy, ody, orig, K, kdy, ly, isOdd, k, id, od);
            }
        } else {
            var idL = inL.getData(),  idH = inH.getData(),
                odL = outL.getData(), odH = outH.getData();
            for (i = bi(), o = bo(); i !== ei; i = it(), o = ot()) {
                yx0 = ys + i;
                nyx = ly + i;
                filter1D(yx0, o, oys, nyx, dy, ody, orig, K, kdy, ly, isOdd, kL, kH, idL, idH, odL, odH);
            }
        }
    };

    var zeros = Matrix.zeros;
    
    var getPaddingInfos = function (name, s) {
        var wav = Matrix.wfilters(name, &#39;d&#39;);
        var K = wav[0].getData().length;

        var isOdd = s % 2 ? true : false;
        var f = Math.floor, c = Math.ceil;
        // left and right part of filter (computed on reversed filter)
        var lk = f((K - 1) / 2), rk = c((K - 1) / 2);
        // Left and right input padding
        var li = K - 2, ri = K - 2 + (isOdd ? 1 : 0);
        // Left and right output padding
        var lo = f(li / 4), ro = c(ri / 4);
        // On odd signal, the length of output corresponding to
        // the signal without considering padding depend if we start
        // on the first or on the second value. This starting point
        // depends itself on if we have K % 4 equal to zero or not. 
        if (isOdd &amp;&amp; (K % 4) !== 0) {
            ro--;
        }
        if (dwtmode === &#39;per&#39;) {
        } 
        return {&quot;lk&quot;: lk, &quot;rk&quot;: rk, &quot;li&quot;: li, &quot;lo&quot;: lo, &quot;ri&quot;: ri, &quot;ro&quot;: ro};
    };
    var padTest = function (isOdd) {
        console.log(&quot;For &quot; + (isOdd ? &quot;odd&quot; : &quot;even&quot;) + &quot; signal&quot;);
        var data = {}, f = Math.floor, c = Math.ceil;
        for (var K = 2; K &lt; 16; K += 2) {
            data[K] = getPaddingInfos(K, isOdd ? 1 : 2);
        }
        console.table(data, [&quot;lk&quot;, &quot;rk&quot;, &quot;li&quot;, &quot;ri&quot;, &quot;lo&quot;, &quot;ro&quot;]);
    };

    var dwt = function (s, name, dim) {
        dim = dim || 0;
        var size = s.getSize();
        var p = getPaddingInfos(name, size[dim]);
        size[dim] = Math.ceil(size[dim] / 2) + p.ro + p.lo;
        if (p.li !== 0 || p.ri !== 0) {
            s = s.paddim(dwtmode === &quot;per&quot; ? &quot;per2&quot; : dwtmode, dim, [p.li, p.ri]);
        }
        // Create output data
        var dL = zeros(size), dH = zeros(size);
        var v = dL.getView().swapDimensions(0, dim);
        var iV = s.getView().swapDimensions(0, dim);
        // H filtering from signal to output
        filterND(s, s, iV, name, true, &#39;cr&#39;, 2, dL, dH, v);
        if (dwtmode === &quot;per&quot;) {
            var K = Matrix.wfilters(name)[0].numel();
            var lc = Math.ceil((K - 2) / 4), rc = Math.floor((K - 2) / 4);
            v = v.restore().selectDimension(dim, [lc, -rc - 1]);
            dL = dL.extractViewFrom(v);
            dH = dH.extractViewFrom(v);
        }   
        return [dL, dH];
    };
    var idwt = function (bands, name, dim, out) {
        dim = dim || 0;
        var n = bands[0] ? 0 : 1;
        var bL = bands[0], bH = bands[1];
        if (dwtmode === &quot;per&quot;) {
            var K = Matrix.wfilters(name)[0].numel();
            var lc = Math.ceil((K - 2) / 4), rc = Math.floor((K - 2) / 4);
            bL = bL ? bL.paddim(dwtmode, dim, [lc, rc]) : undefined;
            bH = bH ? bH.paddim(dwtmode, dim, [lc, rc]) : undefined;
        }   

        var p = getPaddingInfos(name, (bL || bH).getSize(dim));
        var offset = p.lk + p.rk;

        var size = (bL || bH).getSize();
        size[dim] = 2 * size[dim] + 1; 
        var dL = bL ? zeros(size) : undefined,
            dH = bH ? zeros(size) : undefined,
            dV = new MatrixView(size).selectDimension(dim, [1, 2, -1]);

        if (dL) {
            bL.extractViewTo(dV, dL);
        }
        if (dH) {
            bH.extractViewTo(dV, dH);
        }

        // Out array
        dV.restore().swapDimensions(0, dim);
        size[dim] -= offset;
        if (out !== undefined &amp;&amp; !Tools.checkSizeEquals(out.getSize(), size)) {
            throw new Error(&quot;idwt: Wrong output size.&quot;);
        }
        out = out || zeros(size);
        var vO = out.getView().swapDimensions(0, dim);

        // Process scale
        filterND(dL, dH, dV, name, false, &#39;cl&#39;, 1, out, out, vO);
        return out;
    };
    
    var dwt2 = function (im, name) {
        var h = im.getSize(0), w = im.getSize(1), c = im.getSize(2);
        
        // Create output image
        var ph = getPaddingInfos(name, h);
        var hh = Math.ceil(h / 2) + ph.ro + ph.lo;
        if (ph.li !== 0 || ph.ri !== 0) {
            im = im.paddim(dwtmode === &quot;per&quot; ? &quot;per2&quot; : dwtmode, 0, [ph.li, ph.ri]);
        }
        
        // Buffer image
        var bL = zeros(hh, w, c), bH = zeros(hh, w, c);
        var vB = bL.getView();

        // H filtering from image to buffer
        var vI = im.getView();
        filterND(im, im, vI, name, true, &#39;cr&#39;, 2, bL, bH, vB);

        var pw = getPaddingInfos(name, w);
        var hw = Math.ceil(w / 2) + pw.ro + pw.lo;
        if (pw.li !== 0 || pw.ri !== 0) {
            bH = bH.paddim(dwtmode, 1, [pw.li, pw.ri]);
            bL = bL.paddim(dwtmode, 1, [pw.li, pw.ri]);
            vB = bL.getView();
        }

        // V filtering from buffer to data
        var dA = zeros(hh, hw, c), dV = zeros(hh, hw, c),
            dH = zeros(hh, hw, c), dD = zeros(hh, hw, c);

        var v = dA.getView().swapDimensions(0, 1);

        vB.swapDimensions(0, 1);
        filterND(bL, bL, vB, name, true, &#39;cr&#39;, 2, dA, dH, v);
        filterND(bH, bH, vB, name, true, &#39;cr&#39;, 2, dV, dD, v);
        if (dwtmode === &quot;per&quot;) {
            var K = Matrix.wfilters(name)[0].numel();
            var lc = Math.ceil((K - 2) / 4), rc = Math.floor((K - 2) / 4);
            dA = dA.get([lc, -rc - 1], [lc, -rc - 1]);
            dH = dH.get([lc, -rc - 1], [lc, -rc - 1]);
            dV = dV.get([lc, -rc - 1], [lc, -rc - 1]);
            dD = dD.get([lc, -rc - 1], [lc, -rc - 1]);
        }         
        return [dA, dH, dV, dD];
    };
    var idwt2 = function (bands, name) {
        bands = bands.slice();
        if (dwtmode === &quot;per&quot;) {
            var K = Matrix.wfilters(name)[0].numel();
            var lc = Math.ceil((K - 2) / 4), rc = Math.floor((K - 2) / 4);
            for (var b = 0; b &lt; 4; b++) {
                bands[b] = bands[b] ? bands[b].padarray(dwtmode === &quot;per&quot; ? &quot;per&quot; : dwtmode, [lc, rc], [lc, rc]) : undefined;
            }
        }   
        var size = (bands[0] || bands[1] || bands[2] || bands[3]).getSize();

        var ph = getPaddingInfos(name, size[0]),
            pw = getPaddingInfos(name, size[1]);
        var oh = ph.rk + ph.lk;
        var ow = pw.rk + pw.lk;

        size[0] = 2 * size[0] + 1;
        var dL = (bands[0] || bands[1]) ? zeros(size) : undefined,
            dH = (bands[2] || bands[3]) ? zeros(size) : undefined,
            dV = new MatrixView(size);

        size[0] -= oh;
        size[1] = 2 * size[1] + 1;
        var bL = (bands[0] || bands[2]) ? zeros(size) : undefined, 
            bH = (bands[1] || bands[3]) ? zeros(size) : undefined,
            bV = new MatrixView(size).select([], [1, 2, -1]);
        
        if (bL) {
            if (dL) {
                dL.set([1, 2, -1], bands[0]);
            }
            if (dH) {
                dH.set([1, 2, -1], bands[2]);
            }
            filterND(dL, dH, dV, name, false, &#39;cl&#39;, 1, bL, bL, bV);
        }
        if (bH) {
            if (dL) {
                dL.set([1, 2, -1], bands[1]);
            }
            if (dH) {
                dH.set([1, 2, -1], bands[3]);
            }      
            filterND(dL, dH, dV, name, false, &#39;cl&#39;, 1, bH, bH, bV);
        }

        size[1] -= ow;
        var out = zeros(size), oV = new MatrixView(size).swapDimensions(0, 1);
        bV.restore().swapDimensions(0, 1);
        filterND(bL, bH, bV, name, false, &#39;cl&#39;, 1, out, out, oV);
        return out;
    };

<span id='Matrix-method-dwtmaxlev'>    /** Returns the maximum level of the decomposition according 
</span>     * to a mother wavelet name.
     *
     * __See also :__
     * {@link Matrix#wavedec2},
     * {@link Matrix#waverec2},
     * {@link Matrix#idwt2}.
     *
     * @param {Matrix} sizes
     *  Matrix containing the size(s) of the signal to decompose.
     * @param {String} name
     *  Wavelet name.
     * @return {Number}
     * @matlike
     */
    Matrix.dwtmaxlev = function (s, name) {
        s = Matrix.toMatrix(s).min().getDataScalar();
        var wav = Matrix.wfilters(name);
        var dl = wav[0].numel(),
            dh = wav[1].numel(),
            rl = wav[2].numel(),
            rh = wav[3].numel();
        var w = Math.max(dl, dh, rl, rh);
        var maxlev = Math.floor(Math.log(s / (w - 1)) / Math.log(2));
        return maxlev &lt; 0 ? 0 : maxlev;
    };
  
    var createStruct1D = function (s, n, name, dim) {
        var sizes = new Uint16Array(n + 2);
        sizes[n + 1] = s.getSize(dim);

        var K = Matrix.wfilters(name)[0].numel();
        var lc = Math.ceil((K - 2) / 4), rc = Math.floor((K - 2) / 4);
        
        for (var l = n; l &gt;= 1; l--) {
            var py = getPaddingInfos(name, sizes[l + 1]);
            sizes[l] = Math.ceil(sizes[l + 1] / 2) + py.ro + py.lo - (dwtmode === &quot;per&quot; ? lc + rc : 0);
        }
        sizes[0] = sizes[1];
        return Matrix.toMatrix(sizes);
    };
    var getSubbandsCoordinates1D = function (wt, dim) {
        var sizes = wt.get([], 0).getData();

        var outSize = sizes[0];
        var bands = [0, outSize], subSizes = [];
        
        var j, J = sizes.length - 2;
        for (j = 1; j &lt; J + 1; j++) {
            subSizes.push(sizes[j]);
            outSize += sizes[j];
            bands.push(outSize);
        }
        return {
            &quot;bands&quot;: bands,
            &quot;outSize&quot;: outSize,
            &quot;subSizes&quot;: subSizes,
            &quot;sizes&quot;: sizes,
            &quot;J&quot;: J
        };
    };
    var resizeMatrix1d = function (A, ds, l, dim) {
        if (A.getSize(dim) !== ds.sizes[l + 1]) {
            var AView = A.getView().selectDimension(dim, [0, ds.sizes[l + 1] - 1]);
            A = A.extractViewFrom(AView);
        }
        return A;
    };
   
<span id='Matrix-method-dwt'>    /** Compute the 1D DWT (Discrete Wavelet Transform)
</span>     * of a column vector.
     * __See also :__
     * {@link Matrix#idwt},
     * {@link Matrix#dwt2}.
     *
     * @param {Matrix} signal
     * @param {String} [name=&#39;haar&#39;]
     *  Wavelet name.
     * @param {Number} [dim=0]
     *  Dimension on which perform th dwt.
     * @return {Array}
     *  Array containing approximation coefficients and details.
     * @matlike
     */
    Matrix.dwt = dwt;
<span id='Matrix-method-idwt'>    /** Compute the 1D inverse DWT (Discrete Wavelet Transform).
</span>     *
     * __See also :__
     * {@link Matrix#dwt},
     * {@link Matrix#idwt2}.
     * @param {Array} bands
     *  Array containing approximation and details coefficients.
     * @param {String} [name=&#39;haar&#39;]
     *  Wavelet name.
     * @param {Number} [dim=0]
     *  Dimension on which perform th idwt.
     * @return {Matrix}
     *  Matrix with the reconstructed signal.
     * @matlike
     */
    Matrix.idwt = idwt;
    
<span id='Matrix-method-wavedec'>    /** Perform a DWT (Discrete Wavelet Transform)
</span>     * on each vector presents on a given Matrix dimension.
     *
     * __See also :__
     * {@link Matrix#waverec},
     * {@link Matrix#dwt}.
     *
     * @param {Matrix} signal
     * @param {Number} n
     *  Number of level of the decomposition.
     * @param {String} name
     *  Wavelet name.
     * @param {Number} [dimension=0] 
     *  Dimension on which the transformation is performed.
     * @return {Array}
     *  Array of two elements, one contains the coefficients 
     *  while the seconds contains the sizes of each subbands.
     * @matlike
     */
    Matrix.wavedec = function (s, n, name, dim) {
        dim = dim || 0;
        var sd = createStruct1D(s, n, name, dim);
        var ds = getSubbandsCoordinates1D(sd, dim);

        var size = s.getSize();
        size[dim] = ds.outSize;
        var matOut = zeros(size), outView = matOut.getView();
        var matIn = s, dL, dH, wt;
        for (var l = n; l &gt;= 1; l--) {
            wt = dwt(matIn, name, dim);
            outView.selectDimension(dim, [ds.bands[l], ds.bands[l + 1] - 1]);
            wt[1].extractViewTo(outView, matOut);
            outView.restore();
            matIn = wt[0];
        }
        outView.selectDimension(dim, [ds.bands[0], ds.bands[1] - 1]);
        wt[0].extractViewTo(outView, matOut);
        return [matOut, sd];
    };
<span id='Matrix-method-waverec'>    /** Reconstruct the signal from a DWT (Discrete Wavelet Transform)
</span>     * on many of a column vector.
     *
     * __See also :__
     * {@link Matrix#wavedec},
     * {@link Matrix#idwt}.
     *
     * @param {Array} dwt
     *  Array of two elements, one contains the dwt coefficients 
     *  while the seconds concontains the sizes of each subbands.
     * @param {String} name
     *  Wavelet name.
     * @param {Number} [dimension=0] 
     *  Dimension on which the transformation has been performed.
     * @return {Matrix}
     *  The reconstructed signal.
     * @matlike
     */
    Matrix.waverec = function (wt, name, dim) {
        dim = dim || 0;
        var ds = getSubbandsCoordinates1D(wt[1], dim);
        var input = wt[0], iV = input.getView();
        var dLView = iV.selectDimension(dim, [ds.bands[0], ds.bands[1] - 1]);
        var dL = input.extractViewFrom(dLView);

        for (var l = 1; l &lt; ds.bands.length - 1; l++) {
            var dHView = iV.restore().selectDimension(dim, [ds.bands[l], ds.bands[l + 1] - 1]);
            var dH = input.extractViewFrom(dHView);
            dL = idwt([dL, dH], name, dim);
            dL = resizeMatrix1d(dL, ds, l, dim);
        }
        return dL;
    };
<span id='Matrix-method-upwlev'>    /** Reconstruct the signal from a 1D DWT (Discrete Wavelet Transform)
</span>     * at the coarsest level.
     *
     * __See also :__
     * {@link Matrix#wavedec},
     * {@link Matrix#waverec},
     * {@link Matrix#idwt}.
     *
     * @param {Array} dwt
     *  Array of two elements, one contains the dwt coefficients 
     *  while the seconds contains the sizes of each subbands.
     * @param {String} name
     *  Wavelet name.
     * @return {Array}
     *  Array of three elements, one contains the coefficients 
     *  the second contains the sizes of each subbands, and the third 
     *  contains the approximation coefficients at the scale j-1.
     * @matlike
     */
    Matrix.upwlev = function (wt, name, dim) {
        if (wt[1].getSize(0) === 2) {
            return [new Matrix(), new Matrix()];
        }
        dim = dim || 0;
        var ds = getSubbandsCoordinates1D(wt[1], dim);
        var input = wt[0], iV = input.getView();
        var dLView = iV.selectDimension(dim, [ds.bands[0], ds.bands[1] - 1]);
        var dLm = input.extractViewFrom(dLView);
        var dHView = iV.restore().selectDimension(dim, [ds.bands[1], ds.bands[2] - 1]);
        var dH = input.extractViewFrom(dHView);
        var dL = idwt([dLm, dH], name, dim);
        dL = resizeMatrix1d(dL, ds, 1, dim);

        var bSize = dL.getSize(dim);
        var oV = iV.restore().selectDimension(dim, [ds.bands[2] - bSize, -1]);
        var o = input.extractViewFrom(oV);
        oV = o.getView().selectDimension(dim, [0, bSize - 1]);
        dL.extractViewTo(oV, o);

        var sizes = wt[1].get([1, -1]);
        sizes.set(0, [], sizes.get(1, []));

        return [o, sizes, dLm];
    };
<span id='Matrix-method-appcoef'>    /** Returns the coefficients corresponding to the approximation subband
</span>     * at a given level.
     *
     * __See also :__
     * {@link Matrix#wrcoef},
     * {@link Matrix#detcoef},
     * {@link Matrix#upwlev},
     * {@link Matrix#wavedec},
     * {@link Matrix#waverec},
     * {@link Matrix#idwt2}.
     *
     * @param {Array} dwt
     *  Array of two elements, one contains the dwt coefficients 
     *  while the seconds contains the sizes of each subbands.
     * @param {String} name
     *  Wavelet name.
     * @param {Number} dim
     *  Dimension along which the signal must be reconstructed.
     * @param {Number} level
     *  The level of the subband between 0 (the original signal) and 
     *  N the decomposition level.
     * @return {Matrix}
     *  If the level corresponds to the last level of decomposition, 
     *  the coefficients returned will be a view on the coefficient
     *  provided. Therefore, a modification on one will affect both.
     * @matlike
     */
    Matrix.appcoef = function (wt, name, dim, j) {
        j = j === undefined ? wt[1].size()[0] - 2 : j;
        var J = wt[1].size(0) - 2;
        if (j &gt; J || j &lt; 0) {
            throw new Error(&quot;Matrix.appcoef: Invalid decomposition level.&quot;);
        }
        while (J &gt; j) {
            wt = Matrix.upwlev(wt, name);
            J = wt[1].size(0) - 2;
        }
        var ds = getSubbandsCoordinates1D(wt[1], dim);
        var input = wt[0], iV = input.getView();
        var dLView = iV.selectDimension(dim, [ds.bands[0], ds.bands[1] - 1]);
        return input.extractViewFrom(dLView);
    };
<span id='Matrix-method-detcoef'>    /** Returns the coefficients corresponding to a detail subband
</span>     * at a given level.
     *
     * __See also :__
     * {@link Matrix#wavedec},
     * {@link Matrix#waverec},
     * {@link Matrix#wrcoef},
     * {@link Matrix#appcoef}.
     *
     * @param {Array} dwt
     *  Array of two elements, one contains the dwt coefficients 
     *  while the seconds contains the sizes of each subbands.
     * @param {Number} level
     *  The level of the subband between 1 (the coarser) and N the 
     *  decomposition level.
     * @return {Matrix}
     *  Returns the coefficients required. The Matrix returned is a 
     *  view on the coefficient provided. Therefore, a modification 
     *  on one will affect both.
     * @matlike
     */
    Matrix.detcoef = function (wt, dim, j) {
        var ds = getSubbandsCoordinates1D(wt[1], dim);
        if (j &gt; ds.J || j &lt; 1) {
            throw new Error(&quot;Matrix.detcoef2: Invalid decomposition level.&quot;);
        }
        var scale = ds.J - j;
        var input = wt[0], iV = input.getView();
        var dHView = iV.selectDimension(dim, [ds.bands[1 + scale], ds.bands[2 + scale] - 1]);
        return input.extractViewFrom(dHView);
    };
<span id='Matrix-method-wrcoef'>    /** Reconstruct the signal using only one subband.
</span>     *
     * __See also :__
     * {@link Matrix#appcoef},
     * {@link Matrix#detcoef},
     * {@link Matrix#upwlev},
     * {@link Matrix#wavedec},
     * {@link Matrix#waverec}.
     *
     * @param {String} type
     *  Give the subband to use for the reconstruction (&#39;l&#39; or &#39;h&#39;).
     *  The value &#39;l&#39; corresponds to the approximation coefficients (low-pass filter)
     *  while the seconds corresponds to the detail coefficients (high-pass filter).
     * @param {Array} dwt
     *  Array of two elements, one contains the dwt coefficients 
     *  while the seconds contains the sizes of each subbands.
     * @param {String} name
     *  The wavelet filters to use for the reconstruction.
     * @param {Number} dimension
     *  Dimension along which the reconstruction will occur.
     * @param {Number} level
     *  The level of the subband between 1 (the coarser) and N the 
     *  decomposition level.
     * @return {Matrix}
     *  Returns the coefficients required. The Matrix returned is a 
     *  view on the coefficient provided. Therefore, a modification 
     *  on one will affect both.
     * @matlike
     */
    Matrix.wrcoef = function (type, wt, name, dim, N) {
        var L, H;
        if (type === &#39;l&#39;) {
            L = Matrix.appcoef(wt, name, dim, N);
        }  else if (type === &#39;h&#39;) {
            H = Matrix.detcoef(wt, dim, N);
        } 
        var ds = getSubbandsCoordinates1D(wt[1]);
        for (var n = 0; n &lt; N; n++) {
            L = idwt([L, H], name, dim);
            L = resizeMatrix1d(L, ds, ds.J - N + n + 1, dim);
            H = undefined; 
        }
        return L;
    };
   
    var createStruct = function (s, n, name) {
        var K = Matrix.wfilters(name)[0].numel();
        var lc = Math.ceil((K - 2) / 4), rc = Math.floor((K - 2) / 4);
        var xSizes = new Array(n + 2);  
        var ySizes = new Array(n + 2);
        var cSizes = new Array(n + 2);
        ySizes[n + 1] = s.getSize(0);
        xSizes[n + 1] = s.getSize(1);
        cSizes[n + 1] = s.getSize(2);
        for (var l = n; l &gt;= 1; l--) {
            var py = getPaddingInfos(name, ySizes[l + 1]),
                px = getPaddingInfos(name, xSizes[l + 1]);
            ySizes[l] = Math.ceil(ySizes[l + 1] / 2) + py.ro + py.lo - (dwtmode === &quot;per&quot; ? lc + rc : 0);
            xSizes[l] = Math.ceil(xSizes[l + 1] / 2) + px.ro + px.lo - (dwtmode === &quot;per&quot; ? lc + rc : 0);
            cSizes[l] = cSizes[l + 1];
        }
        ySizes[0] = ySizes[1];
        xSizes[0] = xSizes[1];
        cSizes[0] = cSizes[1];
        return Matrix.toMatrix([ySizes, xSizes, cSizes]);
    };
    var getSubbandsCoordinates = function (wt) {
        var ySizes = wt.get([], 0).getData(),
            xSizes = wt.get([], 1).getData(),
            cSizes = wt.get([], 2).getData();

        var outSize = xSizes[0] * ySizes[0] * cSizes[0];
        var bands = [0, outSize], subSizes = [];
        
        var j, J = ySizes.length - 2;
        for (j = 1; j &lt; J + 1; j++) {
            subSizes.push([ySizes[j], xSizes[j], cSizes[j]]);
            var subBandSize = ySizes[j] * xSizes[j] * cSizes[j];
            for (var b = 0; b &lt; 3; b++) {
                outSize += subBandSize;
                bands.push(outSize);
            }
        }
        return {
            &quot;bands&quot;: bands,
            &quot;outSize&quot;: outSize,
            &quot;subSizes&quot;: subSizes,
            &quot;ySizes&quot;: ySizes,
            &quot;xSizes&quot;: xSizes,
            &quot;cSizes&quot;: cSizes,
            &quot;J&quot;: J
        };
    };
    // Function used to resize approximation coefficient matrix
    // to its original size after reconstruction.
    var resizeMatrix = function (A, ds, l) {
        if (A.getSize(0) !== ds.ySizes[l + 1] || A.getSize(1) !== ds.xSizes[l + 1]) {
            A = A.get([0, ds.ySizes[l + 1] - 1], [0, ds.xSizes[l + 1] - 1], []);
        }
        return A;
    };

<span id='Matrix-method-dwt2'>    /** Compute the 2D DWT (Discrete Wavelet Transform)
</span>     * of a column vector.
     * __See also :__
     * {@link Matrix#idwt},
     * {@link Matrix#dwt2}.
     *
     * @param {Matrix} signal
     * @param {String} name
     *  Wavelet name.
     * @return {Array}
     *  Array containing approximation coefficients and details.
     * @matlike
     */
    Matrix.dwt2 = dwt2;
<span id='Matrix-method-idwt2'>    /** Compute the 2D inverse DWT (Discrete Wavelet Transform).
</span>     *
     * __See also :__
     * {@link Matrix#dwt},
     * {@link Matrix#idwt2}.
     * @param {Array} bands
     *  Array containing approximation and details coefficients.
     * @param {String} name
     *  Wavelet name.
     * @return {Matrix}
     *  Matrix with the reconstructed signal.
     * @matlike
     */
    Matrix.idwt2 = idwt2;

<span id='Matrix-method-wavedec2'>    /** Perform a 2D DWT (Discrete Wavelet Transform)
</span>     *
     * __See also :__
     * {@link Matrix#waverec2},
     * {@link Matrix#dwt2}.
     *
     * @param {Matrix} signal
     * @param {Number} n
     *  Number of level of the decomposition.
     * @param {String} name
     *  Wavelet name.
     * @return {Array}
     *  Array of two elements, one contains the coefficients 
     *  while the seconds contains the sizes of each subbands.
     * @matlike
     */
    Matrix.wavedec2 = function (input, n, name) {
        var sizes = createStruct(input, n, name),
            ds = getSubbandsCoordinates(sizes),
            out = new Float64Array(ds.outSize),
            wt;
        for (var l = n - 1, s = 3 * l; l &gt;= 0; l--, s -= 3) {
            wt = dwt2(input, name);
            out.subarray(ds.bands[s + 1], ds.bands[s + 2]).set(wt[1].getData());
            out.subarray(ds.bands[s + 2], ds.bands[s + 3]).set(wt[2].getData());
            out.subarray(ds.bands[s + 3], ds.bands[s + 4]).set(wt[3].getData());
            input = wt[0];
        }
        out.subarray(ds.bands[0], ds.bands[1]).set(wt[0].getData());
        return [new Matrix([out.length], out), sizes];
    };
<span id='Matrix-method-waverec2'>    /** Reconstruct the signal from a 2D DWT (Discrete Wavelet Transform).
</span>     *
     * __See also :__
     * {@link Matrix#wavedec2},
     * {@link Matrix#idwt2}.
     *
     * @param {Array} dwt
     *  Array of two elements, one contains the dwt coefficients 
     *  while the seconds contains the sizes of each subbands.
     * @param {String} name
     *  Wavelet name.
     * @return {Array}
     *  The reconstructed signal.
     * @matlike
     */
    Matrix.waverec2 = function (wt, name) {
        var ds = getSubbandsCoordinates(wt[1]), data = wt[0].getData();
        var A, H, V, D;
        A = new Matrix(ds.subSizes[0], data.subarray(ds.bands[0], ds.bands[1]));
        for (var l = 0, s = 0, J = ds.J; l &lt; J; l++, s += 3) {
            var size = ds.subSizes[l];
            H = new Matrix(size, data.subarray(ds.bands[s + 1], ds.bands[s + 2]));
            V = new Matrix(size, data.subarray(ds.bands[s + 2], ds.bands[s + 3]));
            D = new Matrix(size, data.subarray(ds.bands[s + 3], ds.bands[s + 4]));
            A = idwt2([A, H, V, D], name);
            A = resizeMatrix(A, ds, l + 1);
        }
        return A;
    };
<span id='Matrix-method-upwlev2'>    /** Reconstruct the signal from a 2D DWT (Discrete Wavelet Transform)
</span>     * at the coarsest level.
     *
     * __See also :__
     * {@link Matrix#wavedec2},
     * {@link Matrix#waverec2},
     * {@link Matrix#idwt2}.
     *
     * @param {Array} dwt
     *  Array of two elements, one contains the dwt coefficients 
     *  while the seconds contains the sizes of each subbands.
     * @param {String} name
     *  Wavelet name.
     * @return {Array}
     *  Array of three elements, one contains the coefficients 
     *  the second contains the sizes of each subbands, and the third 
     *  contains the approximation coefficients at the scale j-1.
     * @matlike
     */
    Matrix.upwlev2 = function (wt, name) {
        if (wt[1].getSize(0) === 2) {
            return [new Matrix(), new Matrix()];
        }

        var ds = getSubbandsCoordinates(wt[1]), data = wt[0].getData();
        var Am = new Matrix(ds.subSizes[0], data.subarray(ds.bands[0], ds.bands[1]));
        var H = new Matrix(ds.subSizes[0], data.subarray(ds.bands[1], ds.bands[2]));
        var V = new Matrix(ds.subSizes[0], data.subarray(ds.bands[2], ds.bands[3]));
        var D = new Matrix(ds.subSizes[0], data.subarray(ds.bands[3], ds.bands[4]));
        var A = idwt2([Am, H, V, D], name);
        A = resizeMatrix(A, ds, 1);

        var sizes = wt[1].get([1, -1]);
        sizes.set(0, [], sizes.get(1, []));

        var Asize = A.numel(), remaining = data.length - ds.bands[4];
        var out = new Float64Array(Asize + remaining);
        out.subarray(0, Asize).set(A.getData());
        out.subarray(Asize).set(data.subarray(ds.bands[4]));
        return [new Matrix([out.length], out), sizes, Am];
    };
<span id='Matrix-method-appcoef2'>    /** Returns the coefficients corresponding to the approximation subband
</span>     * at a given level.
     *
     * __See also :__
     * {@link Matrix#detcoef2},
     * {@link Matrix#wavedec2},
     * {@link Matrix#waverec2},
     * {@link Matrix#idwt2}.
     *
     * @param {Array} dwt
     *  Array of two elements, one contains the dwt coefficients 
     *  while the seconds contains the sizes of each subbands.
     * @param {String} name
     *  Wavelet name.
     * @param {Number} level
     *  The level of the subband between 0 (the original signal) and 
     *  N the decomposition level.
     * @return {Matrix}
     *  If the level corresponds to the last level of decomposition, 
     *  the coefficients returned will be a view on the coefficient
     *  provided. Therefore, a modification on one will affect both.
     * @matlike
     */
    Matrix.appcoef2 = function (wt, name, j) {
        j = j === undefined ? wt[1].size()[0] - 2 : j;
        var J = wt[1].size(0) - 2;
        if (j &gt; J || j &lt; 0) {
            throw new Error(&quot;Matrix.appcoef2: Invalid decomposition level.&quot;);
        }
        while (J &gt; j) {
            console.log(&quot;upwlev&quot;);
            wt = Matrix.upwlev2(wt, name);
            J = wt[1].size(0) - 2;
        }
        var sizes = wt[1].get([1, -1]).prod(1).getData();
        var data = wt[0].getData();
        var size = wt[1].get(0).getData();
        return new Matrix(size, data.subarray(0, sizes[0]));
    };
<span id='Matrix-method-detcoef2'>    /** Returns the coefficients corresponding to a detail subband
</span>     * at a given level.
     *
     * __See also :__
     * {@link Matrix#wavedec2},
     * {@link Matrix#waverec2},
     * {@link Matrix#appcoef2}.
     *
     * @param {String} type
     *  Can be either &#39;h&#39;, &#39;v&#39; or &#39;d&#39;.&#39;
     * @param {Array} dwt
     *  Array of two elements, one contains the dwt coefficients 
     *  while the seconds contains the sizes of each subbands.
     * @param {Number} level
     *  The level of the subband between 1 (the coarser) and N the 
     *  decomposition level.
     * @return {Matrix}
     *  Returns the coefficients required. The Matrix returned is a 
     *  view on the coefficient provided. Therefore, a modification 
     *  on one will affect both.
     * @matlike
     */
    Matrix.detcoef2 = function (type, wt, j) {
        if (type === &#39;all&#39;) {
            return [
                Matrix.detcoef2(&#39;h&#39;, wt, j),
                Matrix.detcoef2(&#39;v&#39;, wt, j),
                Matrix.detcoef2(&#39;d&#39;, wt, j)
            ];
        }
        var ds = getSubbandsCoordinates(wt[1]), data = wt[0].getData();
        if (j &gt; ds.J || j &lt; 1) {
            throw new Error(&quot;Matrix.detcoef2: Invalid decomposition level.&quot;);
        }
        var scale = ds.J - j;
        var size = wt[1].get([scale + 1], []).getData();
        var band = 1 + scale * 3;
        if (type === &#39;v&#39;) {
            band += 1;
        } else if (type === &#39;d&#39;) {
            band += 2;
        } else if (type !== &#39;h&#39;) {
            throw new Error(&quot;Matrix.detcoef2: Wrong type argument&quot;);
        }
        return new Matrix(size, data.subarray(ds.bands[band], ds.bands[band + 1]));
    };
<span id='Matrix-method-wrcoef2'>    /** Reconstruct the image using only one subband.
</span>     *
     * __See also :__
     * {@link Matrix#appcoef2},
     * {@link Matrix#detcoef2},
     * {@link Matrix#upwlev2},
     * {@link Matrix#wavedec2},
     * {@link Matrix#waverec2}.
     *
     * @param {String} type
     *  Give the subband to use for the reconstruction (&#39;a&#39; or &#39;h&#39;, &#39;v&#39; or &#39;d&#39;).
     *  The value &#39;a&#39; corresponds to the approximation coefficients (low-pass filter)
     *  while the others correspond to the detail coefficients (horizontal, vertical and diagonal).
     * @param {Array} dwt
     *  Array of two elements, one contains the dwt coefficients 
     *  while the seconds contains the sizes of each subbands.
     * @param {String} name
     *  The wavelet filters to use for the reconstruction.
     * @param {Number} level
     *  The level of the subband between 1 (the coarser) and N the 
     *  decomposition level.
     * @return {Matrix}
     *  Returns the coefficients required. The Matrix returned is a 
     *  view on the coefficient provided. Therefore, a modification 
     *  on one will affect both.
     * @matlike
     */
    Matrix.wrcoef2 = function (type, wt, name, N) {
        var A, H, V, D;
        if (type === &#39;a&#39;) {
            A = Matrix.appcoef2(wt, name, N);
        }  else if (type === &#39;h&#39;) {
            H = Matrix.detcoef2(&#39;h&#39;, wt, N);
        } else if (type === &#39;v&#39;) {
            V = Matrix.detcoef2(&#39;v&#39;, wt, N);
        } else if (type === &#39;d&#39;) {
            D = Matrix.detcoef2(&#39;d&#39;, wt, N);
        }
        var ds = getSubbandsCoordinates(wt[1]);
        for (var l = 0; l &lt; N; l++) {
            A = idwt2([A, H, V, D], name);
            A = resizeMatrix(A, ds, ds.J - N + l + 1);
            H = V = D = undefined; 
        }
        return A;
    };

    (function () {
        var padIndices = {
            sym: function (s, l, r) {
                var length = s + l + r, sel = new Uint32Array(length);
                var i, j, j2, s2 = 2 * s;
                for (j = l, i = 0; j &gt; 0; j--, i++) {
                    j2 = (j - 1) % s2;
                    sel[i] = j2 &gt;= s ? s2 - j2 - 1: j2;
                }
                for (j = 0; j &lt; s; j++, i++) {
                    sel[i] = j;
                }
                for (j = 0; j &lt; r; j++, i++) {
                    j2 = (j + s) % s2;
                    sel[i] = j2 &gt;= s ? s2 - j2 - 1: j2;
                }
                return sel;
            },
            symw: function (s, l, r) {
                var length = s + l + r, sel = new Uint32Array(length);
                var i, j, j2, s2 = 2 * s;
                i = 0;
                for (j = l; j &gt; 0; j--, i++) {
                    j2 = (j - 1) % (s2 - 2);
                    sel[i] = j2 &gt;= s - 1 ? s2 - 3 - j2 : j2 + 1;
                }
                for (j = 0; j &lt; s; j++, i++) {
                    sel[i] = j;
                }
                for (j = 0; j &lt; r; j++, i++) {
                    j2 = (j + s) % (s2 - 2);
                    sel[i] = j2 &gt;= s - 1? s2 - j2 - 2: j2;
                }
                return sel;
            },
            per: function (s, l, r) {
                var length = s + l + r, sel = new Int32Array(length);
                var i, j;
                for (i = 0, j = l; j &gt; 0; j--, i++) {
                    sel[i] = s - (j - 1) % s - 1;
                }
                for (j = 0; j &lt; s; j++, i++) {
                    sel[i] = j;
                }
                for (j = 0; j &lt; r; j++, i++) {
                    sel[i] = j % s;
                }
                return sel;
            },
            per2: function (s, l, r) {
                var isOdd = s % 2;
                s += isOdd ? 1 : 0;
                r -= isOdd ? 1 : 0;
                var length = s + l + r, sel = new Int32Array(length);
                var i, j;
                for (i = 0, j = l; j &gt; 0; j--, i++) {
                    sel[i] = s - (j - 1) % s - 1;
                }
                for (j = 0; j &lt; s; j++, i++) {
                    sel[i] = j;
                }
                for (j = 0; j &lt; r; j++, i++) {
                    sel[i] = j % s;
                }
                if (isOdd) {
                    for (i = 0; i &lt; sel.length; i++) {
                        if (sel[i] == s - 1) {
                            sel[i]--;
                        }
                    }                    
                }
                return sel;
            },
            nn: function (s, l, r) {
                var length = s + l + r, sel = new Uint32Array(length);
                var i, j, i0, ie;
                i = 0;
                for (j = l; j &gt; 0; j--, i++) {
                    sel[i] = 0;
                }
                for (j = 0; j &lt; s; j++, i++) {
                    sel[i] = j;
                }
                for (j = 0; j &lt; r; j++, i++) {
                    sel[i] = s - 1;
                }
                return sel;
            }
        };

        Matrix_prototype.paddim = function (mode, dim, s) {
            var args = [mode];
            for (var d = 0; d &lt; dim; d++) {
                args.push([]);
            }
            args.push(s);
            return this.padarray.apply(this, args);
        };
        
        Matrix_prototype.padarray = function () {
            var mode = Array.prototype.shift.apply(arguments);
            var sel, args = [], d, s;
            if (mode !== &#39;zpd&#39;) {
                var fun = padIndices[mode];
                if (fun === undefined) {
                    throw new Error(&quot;Matrix.padarray: Unimplemented mode &quot; + mode + &quot;.&quot;);
                }
                for (d = 0; d &lt; arguments.length; d++) {
                    s = arguments[d];
                    if (Tools.isInteger(s)) {
                        sel = [fun(this.getSize(d), s, s)];
                    } else if (Tools.isArrayLike(s) &amp;&amp; s.length === 0) {
                        sel = [];
                    } else {
                        sel = [fun(this.getSize(d), s[0], s[1])];
                    }
                    args.push(sel);
                }
                return this.get.apply(this, args);
            }
            var size = this.getSize();
            for (d = 0; d &lt; arguments.length; d++) {
                s = arguments[d];
                size[d] = size[d] ? size[d] : 1;
                if (Tools.isInteger(s)) {
                    sel = [s, -s - 1];
                    size[d] += 2 * s;
                } else if (Tools.isArrayLike(s) &amp;&amp; s.length === 0) {
                    sel = [];
                } else {
                    sel = [s[0], -s[1] - 1];
                    size[d] += s[0] + s[1];
                }
                args.push(sel);
            }
            args.push(this);
            var out = Matrix.zeros(size);
            return out.set.apply(out, args);
        };
    })();

})(Matrix, Matrix.prototype);
</pre>
</body>
</html>
