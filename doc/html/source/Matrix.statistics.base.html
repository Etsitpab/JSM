<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * @author Baptiste Mazin     &lt;baptiste.mazin@telecom-paristech.fr&gt;
 * @author Guillaume Tartavel &lt;guillaume.tartavel@telecom-paristech.fr&gt;
 */

<span id='Matrix'>/** @class Matrix */
</span>
(function (Matrix, Matrix_prototype) {
    &quot;use strict&quot;;

    var min = function (data, s, d, N) {
        for (var i = s + d, e = s + N, m = data[s]; i &lt; e; i += d) {
            if (data[i] &lt; m) {
                m = data[i];
            }
        }
        return m;
    };    

    var amin = function (data, s, d, N) {
        for (var i = s + d, e = s + N, m = data[s], im = s; i &lt; e; i += d) {
            if (data[i] &lt; m) {
                m = data[i];
                im = i;
            }
        }
        return im;
    };    

    var max = function (data, s, d, N) {
        for (var i = s + d, e = s + N, m = data[s]; i &lt; e; i += d) {
            if (data[i] &gt; m) {
                m = data[i];
            }
        }
        return m;
    };    

    var amax = function (data, s, d, N) {
        for (var i = s + d, e = s + N, m = data[s], im = s; i &lt; e; i += d) {
            if (data[i] &gt; m) {
                m = data[i];
                im = i;
            }
        }
        return im;
    };

    var sum = function (data, s, d, N) {
        for (var i = s, e = s + N, m = 0; i &lt; e; i += d) {
            m += data[i];
        }
        return m;
    };    

    var mean = function (data, s, d, N) {
        for (var i = s, e = s + N, m = 0; i &lt; e; i += d) {
            m += data[i];
        }
        return m * d / N;
    };    
    
    var prod = function (data, s, d, N) {
        for (var i = s, e = s + N, m = 1; i &lt; e; i += d) {
            m *= data[i];
        }
        return m;
    };    

    var variance = function (data, s, d, N) {
        var mu = mean(data, s, d, N);
         for (var i = s, e = s + N, m = 0; i &lt; e; i += d) {
            var tmp = data[i] - mu;
            m += tmp * tmp;
        }
        return m * d / (N - 1);
    };    

    var varianceBiased = function (data, s, d, N) {
         return variance(data, s, d, N) * (N - 1) / N;
    };

    var cumsum = function (data, s, d, N) {
        for (var i = s + d, e = s + N; i &lt; e; i += d) {
            data[i] += data[i - d];
        }
    };    

    var cumprod = function (data, s, d, N) {
        for (var i = s + d, e = s + N; i &lt; e; i += d) {
            data[i] *= data[i - d];
        }
    };    

    var getPermutation = function (view, dim) {
        var ndims = view.ndims(), order = [dim];
        for (var i = 0; i &lt; ndims; i++) {
            if (i !== dim) {
                order.push(i);
            }
        }
        return order;
    };

    var applyDim = function (mat, fun, dim, inplace, output) {

        // Do the function fun return a number or act in place ?
        inplace = inplace || false;

        // Check parameter dim
        if (!Tools.isSet(dim)) { 
            if (inplace) {
                fun(mat.getData(), 0, 1, mat.numel());
                return mat;
            }
            var v = fun(mat.getData(), 0, 1, mat.numel());
            return Matrix.toMatrix(v);
        } 

        if (!Tools.isInteger(dim, 0)) {
            throw new Error(&#39;Matrix.applyDim: Invalid dimension.&#39;);
        }

        var view = mat.getView(), order = getPermutation(view, dim);
        view.permute(order);

        // Input Matrix and data
        var id = mat.getData(), iterator = view.getIterator(1);
        var it = iterator.iterator, b = iterator.begin, e = iterator.isEnd;
        var d = view.getStep(0), l = view.getEnd(0);
        var i, io;
        if (!inplace) {
            // Output size and data
            var sizeOut = mat.getSize();
            sizeOut[dim] = 1;
            var om = new Matrix(sizeOut, output), od = new om.getData();
            for (i = b(), io = 0; !e(); i = it(), io++) {
                od[io] = fun(id, i, d, l);
            }
            return om;
        } 
        if (output !== undefined) {
            mat = output;
            output = output.getData();
        }
        for (i = b(); !e(); i = it()) {
            fun(id, i, d, l, output);
        }
        return mat;
    };

<span id='Matrix-method-min'>    /** Return the minimum of a matrix.
</span>     * @param {Number} [dim=undefined]
     *  Dimension on which the computation must be performed. If undefined,
     *  return the global minimum.
     * @return {Matrix}
     */
    Matrix_prototype.min = function (dim) {
        return applyDim(this, min, dim);
    };
<span id='Matrix-method-amin'>    /** Return the argmin of a matrix.
</span>     * @param {Number} [dim=undefined]
     *  Dimension on which the computation must be performed. If undefined,
     *  return the global argmin.
     * @return {Matrix}
     */
    Matrix_prototype.amin = function (dim) {
        return applyDim(this, amin, dim, undefined, &#39;uint32&#39;);
    };
<span id='Matrix-method-max'>    /** Return the maximum of a matrix.
</span>     * @param {Number} [dim=undefined]
     *  Dimension on which the computation must be performed. If undefined,
     *  return the global maximum.
     * @return {Matrix}
     */
    Matrix_prototype.max = function (dim) {
        return applyDim(this, max, dim);
    };
<span id='Matrix-method-amax'>    /** Return the argmax of a matrix.
</span>     * @param {Number} [dim=undefined]
     *  Dimension on which the computation must be performed. If undefined,
     *  return the global argmax.
     * @return {Matrix}
     */
    Matrix_prototype.amax = function (dim) {
        return applyDim(this, amax, dim, undefined, &#39;uint32&#39;);
    };
<span id='Matrix-method-sum'>    /** Return the sum of the matrix elements.
</span>     * @param {Number} [dim=undefined]
     *  Dimension on which the computation must be performed. If undefined,
     *  return the global sum.
     * @return {Matrix}
     */
    Matrix_prototype.sum = function (dim) {
        return applyDim(this, sum, dim);
    };
<span id='Matrix-method-prod'>    /** Return the product of the matrix elements.
</span>     * @param {Number} [dim=undefined]
     *  Dimension on which the computation must be performed. If undefined,
     *  return the product of all the matrix elements.
     * @return {Matrix}
     */
    Matrix_prototype.prod = function (dim) {
        return applyDim(this, prod, dim);
    };
<span id='Matrix-method-mean'>    /** Return the average value of the matrix elements.
</span>     * @param {Number} [dim=undefined]
     *  Dimension on which the computation must be performed. If undefined,
     *  return the average value of all the elements.
     * @return {Matrix}
     */
    Matrix_prototype.mean = function (dim) {
        return applyDim(this, mean, dim);
    };
<span id='Matrix-method-variance'>    /** Return the variance of the matrix elements.
</span>     * @param {Number} [dim=undefined]
     *  Dimension on which the computation must be performed. If undefined,
     *  return the variance of all the elements.
     * @param {Number} [norm=false]
     *  If false, use the non biased variance estimator (N - 1), and the 
     *  biased one otherwise.
     * @return {Matrix}
     */
    Matrix_prototype.variance = function (dim, norm) {
        switch (typeof norm) {
        case &#39;undefined&#39;:
            norm = -1;
            break;
        case &#39;boolean&#39;:
            norm = (norm === false) ? -1 : 0;
            break;
        case &#39;number&#39;:
            if (norm === 0) {
                norm = -1;
            } else if (norm === 1) {
                norm = 0;
            } else {
                throw new Error(&#39;Matrix.variance: Invalid argument.&#39;);
            }
            break;
        default:
            throw new Error(&#39;Matrix.variance: Invalid argument.&#39;);
        }
        if (norm === -1) {
            return applyDim(this, variance, dim);
        } 
        return applyDim(this, varianceBiased, dim);
    };
<span id='Matrix-method-std'>    /** Return the standard deviation of the matrix elements.
</span>     * @param {Number} [dim=undefined]
     *  Dimension on which the computation must be performed. If undefined,
     *  return the standard deviation of all the elements.
     * @param {Number} [norm=false]
     *  If false, use the non biased standard deviation estimator (N - 1), 
     * and the biased one otherwise.
     * @return {Matrix}
     */
    Matrix_prototype.std = function (norm, dim) {
        var v = this.variance(norm, dim);
        if (typeof v === &#39;number&#39;) {
            return Math.sqrt(v);
        }
        return v.arrayfun(Math.sqrt);
    };
<span id='Matrix-method-cumsum'>    /** Return the cumulative sum of the matrix elements.
</span>     * @param {Number} [dim=undefined]
     *  Dimension on which the computation must be performed. If undefined,
     *  return the cumulative sum of all the elements.
     * @return {Matrix}
     */
    Matrix_prototype.cumsum = function (dim) {
        return applyDim(this, cumsum, dim, true);
    };

<span id='Matrix-method-cumprod'>    /** Return the cumulative product of the matrix elements.
</span>     * @param {Number} [dim=undefined]
     *  Dimension on which the computation must be performed. If undefined,
     *  return the cumulative product of all the elements.
     * @return {Matrix}
     */
    Matrix_prototype.cumprod = function (dim) {
        return applyDim(this, cumprod, dim, true);
    };


    (function () {
        var poissrnd_lambda = function (data, lambda) {
            var L = Math.exp(-lambda), random = Math.random;
            for (var i = 0, ie = data.length; i &lt; ie; i++) {
                var p = 1, k = 0;
                do {
                    k++;
                    p *= random();
                } while (p &gt; L);
                data[i] = k - 1;
            }
        };

        var poissrnd_lambdas = function (lambda) {
            var exp = Math.exp, random = Math.random;
            for (var i = 0, ie = lambda.length; i &lt; ie; i++) {
                var p = 1, k = 0, L = exp(-lambda[i]);
                do {
                    k++;
                    p *= random();
                } while (p &gt; L);
                lambda[i] = k - 1;
            }
        };

        var exprnd = function (data, mu) {
            mu = -mu;
            var random = Math.random, log = Math.log;
            for (var i = 0, ie = data.length; i &lt; ie; ++i) {
                data[i] = mu * log(random());
            }
        };

<span id='Matrix-method-poissrnd'>        /** Generate Poisson random numbers. 
</span>         * 
         * The `lambda` parameter can a number as well as a Matrix.
         * - If it is a number then the function returns an array of 
         * dimension `size`.
         * - If `lambda` is a Matrix then the function will return 
         * a Matrix of the same size.
         * 
         * Note that to avoid copy, you can use the syntax `mat.poissrnd()`.
         *
         * @param {Number} lambda
         * @param {Number} [size]
         * @return {Matrix}
         */
        Matrix.poissrnd = function () {
            var lambda = Array.prototype.shift.apply(arguments);
            if (typeof(lambda) === &quot;number&quot;) { 
                var size = Tools.checkSize(arguments, &#39;square&#39;);
                var mat = new Matrix(size), data = mat.getData();
                poissrnd_lambda(data, lambda);
                return mat;
            }
            if (lambda instanceof Matrix) {
                return lambda.getCopy().poissrnd();
            }
        };
        Matrix_prototype.poissrnd = function() {
            poissrnd_lambdas(this.getData());
            return this;
        };
<span id='Matrix-method-exprnd'>        /** Generate exponentially distributed random numbers.
</span>         * @param {Number} mu
         * @param {Number} size
         * @return {Matrix}
         */
        Matrix.exprnd = function () {
            var mu = Array.prototype.shift.apply(arguments);
            var size = Tools.checkSize(arguments, &#39;square&#39;);
            
            var mat = new Matrix(size), data = mat.getData();
            exprnd(data, mu);
            return mat;
        };

    })();

    (function () {
        var tab, itab, fun;
        var asortAscend = function (a, b) {
            return tab[a] - tab[b];
        };
        var asortDescend = function (a, b) {
            return tab[b] - tab[a];
        };
        var sortAscend = function (a, b) {
            return a - b;
        };
        var sortDescend = function (a, b) {
            return b - a;

        };
        var sort = function (data, s, d, N) {
            var i, io, e;
            for (i = s, io = 0, e = s + N; i &lt; e; i += d, io++) {
                tab[io] = data[i];
            }
            Array.prototype.sort.call(tab, fun);
            for (i = s, io = 0, e = s + N; i &lt; e; i += d, io++) {
                data[i] = tab[io];
            }
        };
        var asort = function (data, s, d, N, out) {
            var i, io, e;
            for (i = s, io = 0, e = s + N; i &lt; e; i += d, io++) {
                tab[io] = data[i];
                itab[io] = io;
            }
            Array.prototype.sort.call(itab, fun);
            for (i = s, io = 0, e = s + N; i &lt; e; i += d, io++) {
                out[i] = itab[io] * d + s;
            }
        };

<span id='Matrix-method-sort'>        /** Sort the elements of the matrix.
</span>         * @param {Number} [dim=undefined]
         *  Dimension on which the computation must be performed. If undefined,
         *  return all the elements sorted.
         * @param {String} [mode=&quot;ascend&quot;]
         *  Sorting by increasing values (&quot;ascend&quot;) or decreasing values (&quot;descend&quot;)
         * @chainable
         */
        Matrix_prototype.sort = function (dim, mode) {
            var size = typeof dim === &quot;number&quot; ? this.getSize(dim) : this.numel();
            tab = new Float64Array(size);
            if (mode === &quot;ascend&quot;) { 
                fun = sortAscend;
            } else if (mode === &quot;descend&quot;) {
                fun = sortDescend;
            } else {
                throw new Error(&quot;Matrix.sort: Wrong mode selection&quot;);
            }
            return applyDim(this, sort, dim, true);
        };
        
        Matrix.sort = function (m, dim, mode) {
            return m.getCopy().sort(dim, mode);
        };

<span id='Matrix-method-asort'>        /** Compute the argsort of the elements of the matrix.
</span>         * @param {Number} [dim=undefined]
         *  Dimension on which the computation must be performed. If undefined,
         *  return the global argsort.
         * @param {String} [mode=&quot;ascend&quot;]
         *  Sorting by increasing values (&quot;ascend&quot;) or decreasing values (&quot;descend&quot;)
         * @return {Matrix}
         */
        Matrix_prototype.asort = function (dim, mode) {
            var size = typeof dim === &quot;number&quot; ? this.getSize(dim) : this.numel();
            tab = new Float64Array(size);
            itab = new Uint32Array(size);
            if (mode === &quot;ascend&quot;) { 
                fun = asortAscend;
            } else if (mode === &quot;descend&quot;) {
                fun = asortDescend;
            } else {
                throw new Error(&quot;Matrix.sort: Wrong mode selection&quot;); 
            }
            var out = new Matrix(this.getSize(), &quot;uint32&quot;);
            return applyDim(this, asort, dim, true, out);
       };

        Matrix.asort = function (m, dim, mode) {
            return m.getCopy().asort(dim, mode);
        };

    })();

<span id='Matrix-method-accumarray'>    /** Accumate values in an array
</span>     * @param {Array} subs
     *  Array of integers indicating subscript positions
     * @param {Array} val
     *  Values to be accumulated.
     * @param {Array} [size]
     *  Size of the output Array. Default is subs.max() + 1
     * @return {Matrix}
     */
    Matrix.accumarray = function (subs, val, size) {
        subs = Matrix.toMatrix(subs);
        // Check subs for array of positive integers
        if (!Tools.isArrayOfIntegers(subs.getData(), 0)) {
            throw new Error(&#39;Matrix.accumarray: Subs should be an array of positive integers.&#39;);
        }

        var max = subs.max(0).getData();
        var k, ek, steps = [1];
        if (Tools.isSet(size)) {
            for (k = 0, ek = max.length; k &lt; ek; k++) {
                if (size[k] &lt; max[k] + 1) {
                    throw new Error(&#39;Matrix.accumarray: Size and Subs values are unconsistent.&#39;);
                }
            }
        } else {
            size = [];
            for (k = 0, ek = max.length; k &lt; ek; k++) {
                size[k] = max[k] + 1;
            }
        }
        for (k = 0, ek = size.length - 1; k &lt; ek; k++) {
            steps[k + 1] = steps[k] * size[k];
        }

        if (subs.ndims() &gt; 2) {
            throw new Error(&quot;Matrix.accumarray: Subs must be a 2D Array.&quot;);
        }
        
        // Scaning the from the second dimension (dim = 1)
        var sd = subs.getData(), N = subs.numel(), ni = subs.getSize(0);
        var i, j, _j, ij, s;

        var ind = new Uint32Array(ni);
        for (j = 0, _j = 0; _j &lt; N; j++, _j += ni) {
            for (i = 0, ij = _j, s = steps[j]; i &lt; ni; i++, ij++) {
                ind[i] += sd[ij] * s;
            }
        }

        if (val instanceof Matrix) { 
            val = val.getData();
        } 
        var out = new Matrix(size), od = out.getData();
        if (Tools.isArrayLike(val) &amp;&amp; val.length === ind.length) {
            for (k = 0, ek = ind.length; k &lt; ek; k++) {
                od[ind[k]] += val[k];
            }
        } else if (typeof val === &quot;number&quot;) {
            for (k = 0, ek = ind.length; k &lt; ek; k++) {
                od[ind[k]] += val;
            }
        } else {
            throw new Error(&quot;Matrix.accumarray: Wrong val argument.&quot;);
        }
        return out;
    };

})(Matrix, Matrix.prototype);
</pre>
</body>
</html>
