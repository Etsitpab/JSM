<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * @author Baptiste Mazin     &lt;baptiste.mazin@telecom-paristech.fr&gt;
 * @author Guillaume Tartavel &lt;guillaume.tartavel@telecom-paristech.fr&gt;
 */

var root = typeof window === &#39;undefined&#39; ? module.exports : window;

//////////////////////////////////////////////////////////////////
//                        Keypoint Class                        //
//////////////////////////////////////////////////////////////////


(function (global) {

    var indexCircularPhase = function (phase, nBin) {
        if (phase &lt; 0) {
            phase += 1;
        }
        var k =  Math.floor(phase * nBin + 0.5);
        return (k &gt;= nBin) ? (k - nBin) : k;
    };

<span id='Maxtching-Keypoint-method-constructor'><span id='Maxtching-Keypoint'>    /**
</span></span>     * @class Maxtching.Keypoint
     *
     * This class creates `Keypoint` objects which contains the
     * information on keypoint extracted from an image.
     *
     * @constructor
     * Allows to build `Keypoint`.
     *
     * @param {Number} x
     *  The x location of the keypoint.
     * @param {Number} y
     *  The y location of the keypoint.
     * @param {Number} sigma
     *  The blur factor corresponding to the keypoint.
     * @param {Number} laplacian
     *  The laplacian value of the keypoint.
     */
    function Keypoint(x, y, sigma, laplacian) {
        this.x = x;
        this.y = y;
        this.sigma = sigma;
        this.laplacian = laplacian;
    }

<span id='Maxtching-Keypoint-property-nBin'>    /** Number of bins used to compute the histogram of oriented gradient */
</span>    Keypoint.prototype.nBin = 36;
<span id='Maxtching-Keypoint-property-algorithm'>    /** The algorithm used to compute the main(s) orientation(s) 
</span>     of the keypoint. */
    Keypoint.prototype.algorithm = &quot;max&quot;;
<span id='Maxtching-Keypoint-property-factorSize'>    /** The factor size used to determine the associated region 
</span>     in the image. */
    Keypoint.prototype.factorSize = 18;
<span id='Maxtching-Keypoint-property-descriptors'>    /** The descriptor(s) used to describe the region of the keypoint. */
</span>    Keypoint.prototype.descriptors = [
        global.descriptorDB[&quot;SIFT&quot;],
    ];
<span id='Maxtching-Keypoint-property-criterion'>    /** The criterion used to compare the Keypoint to others. */
</span>    Keypoint.prototype.criterion = &quot;NN-DR&quot;;

<span id='Maxtching-Keypoint-method-toString'>    /** Convert the Keypoint to String for export purposes.
</span>     * The fields to export can be specified as parameters.
     * @param {Boolean} [x = true]
     * @param {Boolean} [y = true]
     * @param {Boolean} [scale = true]
     * @param {Boolean} [orientation = true]
     * @return {String}
     */
    Keypoint.prototype.toString = function (x, y, s, o) {
        x = (x === undefined) ? true : x;
        y = (y === undefined) ? true : y;
        s = (s === undefined) ? true : s;
        o = (o === undefined) ? true : o;
        var str = &quot;&quot;;
        if (x) {
            str += this.x + &quot; &quot;;
        }
        if (y) {
            str += this.y + &quot; &quot;;
        }
        if (s) {
            str += this.sigma + &quot; &quot;;
        }
        if (this.orientation !== undefined &amp; o) {
            str += &quot; &quot; + this.orientation;
        }
        return str;
    };

<span id='Maxtching-Keypoint-method-getCopy'>    /** Return a copy of the keypoint */
</span>    Keypoint.prototype.getCopy = function () {
        var newKeypoint = new Keypoint(this.x, this.y, this.sigma, this.laplacian);
        newKeypoint.nScale = this.nScale;

        if (this.histogram) {
            newKeypoint.histogram = this.histogram;
        }
        if (this.patch) {
            newKeypoint.patch = this.patch;
        }
        if (this.descriptorsData) {
            newKeypoint.descriptorsData = this.descriptorsData;
        }
        if (this.orientation) {
            newKeypoint.orientation = this.orientation;
        }
        return newKeypoint;
    };

<span id='Maxtching-Keypoint-method-extractMainOrientation'>    /** Extract the main(s) orientation(s) from a patch.
</span>     * @param {Object} patch
     * @param {String} [algo]
     */
    Keypoint.prototype.extractMainOrientation = function (patch, algo) {
        this.histogram = new Float32Array(this.nBin);
        var hist = this.histogram;
        var nBin = this.nBin;
        algo = (algo || this.algorithm).toLowerCase();
        this.algorithm = algo;
        var getIndex = indexCircularPhase;

        var dPhase = patch.phase.getData(),
            dNorm = patch.norm.getData(),
            view = patch.view;
        var xs = view.getFirst(1), dx = view.getStep(1), ys = view.getFirst(0);

        var size = view.getSize(0);
        var wSize = Math.floor(size / 2), wSize2 = wSize * wSize;
        var nPoints = 0;
        var exp = Math.exp, c = -2 / wSize2;
        var i, ei, j, _j, ij, j2, r2;
        for (j = 0, _j = xs; j &lt; size; j++, _j += dx) {
            for (i = 0, ij = _j + ys, j2 = (j - wSize) * (j - wSize); i &lt; size; i++, ij++) {
                r2 = j2 + (i - wSize) * (i - wSize);
                if (r2 &gt; wSize2) {
                    continue;
                }
                if (ij &gt;= dPhase.length) {
                    console.log(ij, dPhase.length, i, j, _j);
                    throw new Error();
                }
                var bin = getIndex(dPhase[ij], nBin);
                nPoints++;
                hist[bin] += exp(c * r2) * dNorm[ij];
                // hist[bin] += dNorm[ij];
            }
        }
        var orientations = [];
        switch (algo) {
        case &quot;ac&quot;:
            var l = 0;
            for (i = 0; i &lt; nBin; i++) {
                l += hist[i];
            }
            l = l / nPoints;
            hist.nPoints = nPoints;
            hist.lambda = l;
            var modes = extractModes(hist, true, 0, nPoints, l, l * l);
            hist.modes = modes;
            for (i = 0, ei = modes.length; i &lt; ei; i++) {
                orientations.push(modes[i].phase);
            }
            return orientations;
        case &quot;max&quot;:
            var max = 0;
            for (i = 0, ei = hist.length; i &lt; ei; i++) {
                if (hist[i] &gt; hist[max]) {
                    max = i;
                }
            }
            return [max / nBin];
        default:
            throw new Error(&quot;Keypoint.extractMainOrientation: &quot; +
                            &quot;Wrong algorithm choice: &quot;  + this.algorithm + &quot;.&quot;);
        }
    };

<span id='Maxtching-Keypoint-method-extractDescriptors'>    /** Extract the Descriptors from a patch.
</span>     * @param {Object} patch
     * @param {String} [descriptors]
     */
    Keypoint.prototype.extractDescriptors = function (patch, descriptors, mem) {
        this.descriptors = descriptors || this.descriptors;
        descriptors = this.descriptors;

        this.descriptorsData = {};
        var d, ed, desc, name;
        var data, orientation = this.orientation;
        for (d = 0, ed = descriptors.length; d &lt; ed; d++) {
            desc = descriptors[d];
            name = desc.name;
            data = desc.extractFromPatch(orientation, patch, mem[name]);
            this.descriptorsData[name] = data;
        }
        return this;
    };

<span id='Maxtching-Keypoint-method-computeDistances'>    /** Compute distance between the descriptor(s) of a Keypoint and the
</span>     * descriptors of an Array of keypoints.
     * @param {Array} Keypoints
     * @param {Array} [names]
     *  An Array of strings containings the names of the descriptors to
     *  compare.
     */
    Keypoint.prototype.computeDistances = function (keypoints, names) {
        names = names || this.descriptorsData;

        var getDescriptors = function (keypoints, name) {
            var descriptors = [], i, ei;
            for (i = 0, ei = keypoints.length; i &lt; ei; i++) {
                descriptors[i] = keypoints[i].descriptorsData[name];
            }
            return descriptors;
        };
        var distances = {&quot;length&quot;: keypoints.length};
        var name;
        // Compute distances for each kind of descriptor
        for (name in names) {
            if (names.hasOwnProperty(name)) {
                var dRequest = this.descriptorsData[name];
                var dCandidates = getDescriptors(keypoints, name);
                var descriptor = dRequest.descriptor;
                distances[name] = descriptor.computeDistances(dRequest, dCandidates);
            }
        }
        return distances;
    };

    var conv = function (id1, id2) {
        var n1 = id1.length;
        var n2 = id2.length;

        if (n1 &lt; n2) {
            return conv(id2, id1);
        }

        var od = new Float32Array(n1 + n2 - 1), no = od.length;

        var j0, j, nj, i, x, nx, sum;

        // Initial zero padding
        for (x = 0, nx = n2 - 1; x &lt; nx; x++) {
            for (sum = 0, j = 0, nj = x + 1, i = x; j &lt; nj; j++, i--) {
                sum += id1[j] * id2[i];
            }
            od[x] = sum;
        }
        // Central part
        for (x = n2 - 1, j0 = 0, nx = n1; x &lt; nx; x++, j0++) {
            for (sum = 0, j = j0, nj = x + 1, i = n2 - 1; j &lt; nj; j++, i--) {
                sum += id1[j] * id2[i];
            }
            od[x] = sum;
        }
        // Final zero padding
        for (x = n1, j0 = n1 - n2 + 1; x &lt; no; x++, j0++) {
            for (sum = 0, j = j0, i = n2 - 1; j &lt; n1; j++, i--) {
                sum += id1[j] * id2[i];
            }
            od[x] = sum;
        }
        return od;
    };

    var getHistogram = function (v, bins, step) {
        var f = Math.round;
        var i, ie = v.length;
        var h = new Float32Array(bins);
        for (i = 0; i &lt; ie; i++) {
            var bin = f(v[i] * step);
            if (bin &gt;= bins) {
                h[bins - 1]++;
            } else {
                h[bin]++;
            }
        }
        var sum = 1 / ie;
        for (i = 0; i &lt; bins; i++) {
            h[i] *= sum;
        }
        return h;
    };

    var sumDistances = function (distances, norm) {

        var length = distances.length,
            sumDistances = new Float32Array(length),
            sum, i, j, d, n;

        for (d in distances) {
            if (distances.hasOwnProperty(d)) {
                var dist = distances[d];
                for (i = 0; i &lt; length; i++) {
                    n = distances[d].length;
                    for (sum = 0, j = 0; j &lt; n; j++) {
                        sum += dist[j][i];
                    }
                    sumDistances[i] += sum;
                }
            }
        }
        if (norm) {
            norm = 1 / norm;
            for (i = 0; i &lt; length; i++) {
                sumDistances[i] *= norm;
            }
        }
        return sumDistances;
    };

    var learnDistances = function (distances, bins, step) {
        var histos = {};
        var j, d, n;
        var sumDist = new Float32Array(distances.length);
        var addDist = function (sumDist, dist) {
            var i, ei;
            for (i = 0, ei = dist.length; i &lt; ei; i++) {
                sumDist[i] += dist[i];
            }
            return sumDist;
        };

        for (d in distances) {
            if (distances.hasOwnProperty(d) &amp;&amp; d !== &quot;length&quot;) {
                // One distances per sector and per descriptor
                histos[d] = [];
                for (j = 0, n = distances[d].length; j &lt; n; j++) {
                    histos[d][j] = getHistogram(distances[d][j], bins, step);
                    sumDist = addDist(sumDist, distances[d][j]);
                }
                // One distance per descriptor
                // var dist = sumDistances({d: distances[d], length: distances.length}, distances[d].length);
                // histos[d] = [getHistogram(dist, bins, step)];
                // sumDist = addDist(sumDist, dist);
            }
        }

        /*
         var distTmp;
         for (j = 0, n = distances.SIFT.length; j &lt; n; j++) {
         distTmp = [];
         for (d in distances) {
         if (distances.hasOwnProperty(d) &amp;&amp; d !== &quot;length&quot;) {
         distTmp.push(distances[d][j]);
         }
         }
         var dist = sumDistances({d: distTmp, length: distances.length}, distances.SIFT.length);
         histos[j] = [];
         histos[j][0] = getHistogram(distTmp, bins, step);
         sumDist = addDist(sumDist, distances[d][j]);
         }
         */
        /*
         // One distance per descriptor
         var dist1 = {
         SIFT: distances[&quot;SIFT&quot;],
         OPP1: distances[&quot;OPP1&quot;],
         OPP2: distances[&quot;OPP2&quot;],
         length: distances.length
         };
         var dist = sumDistances(dist1, distances[&quot;SIFT&quot;].length);
         histos[&quot;SIFT&quot;] = [getHistogram(dist, bins * 3, step)];
         sumDist = addDist(sumDist, dist);
         var dist2 = {
         HUE: distances[&quot;HUE&quot;],
         length: distances.length
         };
         dist = sumDistances(dist2, distances[&quot;HUE&quot;].length);
         histos[&quot;HUE&quot;] = [getHistogram(dist, bins, step)];
         sumDist = addDist(sumDist, dist);
         */
        /*
         // One distance per descriptor
         var dist1 = {
         SIFT: distances[&quot;SIFT&quot;],
         length: distances.length
         };
         var dist = sumDistances(dist1, distances[&quot;SIFT&quot;].length);
         histos[&quot;SIFT&quot;] = [getHistogram(dist, bins, step)];
         sumDist = addDist(sumDist, dist);

         var dist2 = {
         HUE: distances[&quot;HUE&quot;],
         length: distances.length
         };
         dist = sumDistances(dist2, distances[&quot;HUE&quot;].length);
         histos[&quot;HUE&quot;] = [getHistogram(dist, bins, step)];
         sumDist = addDist(sumDist, dist);

         var dist3 = {
         OPP1: distances[&quot;OPP1&quot;],
         OPP2: distances[&quot;OPP2&quot;],
         length: distances.length
         };
         dist = sumDistances(dist3, distances[&quot;OPP1&quot;].length * 2);
         histos[&quot;OPP&quot;] = [getHistogram(dist, bins, step)];
         sumDist = addDist(sumDist, dist);
         */
        return {histograms: histos, sum: sumDist};
    };

    var computePdf = function (histos) {
        var pdf;
        var d, i, ie;
        for (d in histos) {
            if (histos.hasOwnProperty(d)) {
                i = 0;
                if (pdf === undefined) {
                    pdf = histos[d][0];
                    i = 1;
                }
                for (ie = histos[d].length; i &lt; ie; i++) {
                    pdf = conv(pdf, histos[d][i]);
                }
            }
        }
        for (i = 1, ie = pdf.length; i &lt; ie; i++) {
            pdf[i] += pdf[i - 1];
        }


        return pdf;
    };

    var NNDT = function (distances) {
        var sumDist = sumDistances(distances);
        var i, ei, iMin = 0, dMin = sumDist[0];
        for (i = 1, ei = sumDist.length; i &lt; ei; i++) {
            if (sumDist[i] &lt; dMin) {
                dMin = sumDist[i];
                iMin = i;
            }
        }
        return [iMin, dMin];
    };

    var NNDR = function (distances) {
        var sumDist = sumDistances(distances);

        var iMin1 = 0, dMin1 = sumDist[0];
        var iMin2, dMin2;
        if (sumDist[1] &lt; dMin1) {
            iMin2 = iMin1;
            dMin2 = dMin1;
            iMin1 = 1;
            dMin1 = sumDist[1];
        } else {
            iMin2 = 1;
            dMin2 = sumDist[1];
        }

        var i, ei;
        for (i = 2, ei = sumDist.length; i &lt; ei; i++) {
            if (sumDist[i] &lt; dMin2) {
                if (sumDist[i] &lt; dMin1) {
                    dMin2 = dMin1;
                    iMin2 = iMin1;
                    iMin1 = i;
                    dMin1 = sumDist[i];
                } else {
                    dMin2 = sumDist[i];
                    iMin2 = i;
                }
            }
        }
        return [iMin1, dMin1 / dMin2];
    };

    var BINS_PROBA = 100, DIST_MAX = 0.15, IDM_BP = BINS_PROBA / DIST_MAX;
    var NNAC = function (distances) {

        var histosSum = learnDistances(distances, BINS_PROBA, IDM_BP);
        var histos = histosSum.histograms, sumDist = histosSum.sum;

        var pdfCum = computePdf(histos);

        var i, ie, iMin = 0, dMin = sumDist[0];
        for (i = 1, ie = sumDist.length; i &lt; ie; i++) {
            if (sumDist[i] &lt; dMin) {
                iMin = i;
                dMin = sumDist[i];
            }
        }
        var bin = Math.round(dMin * IDM_BP);
        dMin = pdfCum[bin] * sumDist.length;
        return [iMin, dMin];
    };

    var AC = function (distances) {
        var histosSum = learnDistances(distances, BINS_PROBA, IDM_BP);
        var histos = histosSum.histograms, sumDist = histosSum.sum;
        var pdfCum = computePdf(histos);
        var i, ie, nfa = [], round = Math.round;
        for (i = 0, ie = sumDist.length; i &lt; ie; i++) {
            var bin = round(sumDist[i] * IDM_BP);
            var dist = pdfCum[bin] * ie;
            if (dist &lt; 1e1) {
                nfa.push([i, dist]);
            }
        }
        return nfa;
    };

    Keypoint.NNDT = NNDT;
    Keypoint.NNAC = NNAC;
    Keypoint.NNDR = NNDR;
    Keypoint.AC = AC;

<span id='Maxtching-Keypoint-method-match'>    /** Compute the distances between the keypoint and a list of candidates
</span>     * then attribute a disimilarity measure to the matches according to
     * a criterion.
     * @param {Array} keypoints
     * @param {String} criterion
     *  Can be either &quot;NN-DT&quot;, &quot;NN-DR&quot;, &quot;NN-AC or &quot;AC&quot;.
     * @param {Array} [names]
     *  An Array of strings containings the names of the descriptors to
     *  compare.
     */
    Keypoint.prototype.match = function (keypoints, criterion, names) {
        // Compute global distances between q query descriptors and a base
        criterion = criterion || this.criterion;
        var distances = this.computeDistances(keypoints, names);

        var m, out = [];
        if (criterion === &quot;NN-DT&quot;) {
            m = NNDT(distances);
            out.push(new global.Match(0, this, m[0], keypoints[m[0]], m[1]));
        } else if (criterion === &quot;NN-DR&quot;) {
            m = NNDR(distances);
            out.push(new global.Match(0, this, m[0], keypoints[m[0]], m[1]));
        } else if (criterion === &quot;NN-AC&quot;) {
            m = NNAC(distances);
            out.push(new global.Match(0, this, m[0], keypoints[m[0]], m[1]));
        } else if (criterion === &quot;AC&quot;) {
            var ms = AC(distances);
            var i, ei;
            for (i = 0, ei = ms.length; i &lt; ei; i++) {
                m = ms[i];
                out.push(new Match(0, this, m[0], keypoints[m[0]], m[1]));
            }
        }
        return out;
    };

    global.Keypoint = Keypoint;
})(Matching);
</pre>
</body>
</html>
