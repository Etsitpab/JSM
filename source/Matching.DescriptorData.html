<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * @author Baptiste Mazin     &lt;baptiste.mazin@telecom-paristech.fr&gt;
 * @author Guillaume Tartavel &lt;guillaume.tartavel@telecom-paristech.fr&gt;
 */

var root = typeof window === &#39;undefined&#39; ? module.exports : window;

//////////////////////////////////////////////////////////////////
//                     DescriptorData Class                     //
//////////////////////////////////////////////////////////////////


(function (global) {

<span id='Matching-DescriptorData-method-constructor'><span id='Matching-DescriptorData'>    /** 
</span></span>     * @class Matching.DescriptorData
     *
     * This class creates Objects dealing with the descriptor datas.
     *
     * @param {Object} descriptor 
     *  Provide the descriptor informations use
     d to create data 
     *  structures.
     * 
     * @param {Array} [mem=[]]
     *   Allow to provide preallocated memory. The size of the Array 
     *   should be `descriptor.nBin * descriptor.nSector`.
     *
     * @constructor
     */
    function DescriptorData(descriptor, mem) {
        var nBin = descriptor.nBin, nSec = descriptor.nSector, h = [];

        var data = mem || new Float32Array(nBin * nSec);
        var i;
        for (i = 0; i &lt; nSec; i++) {
            h[i] = data.subarray(i * nBin, (i + 1) * nBin);
        }
<span id='Matching-DescriptorData-property-descriptor'>        /** Pointer to the Descriptor template.
</span>         * @property {Object} descriptor
         */
        this.descriptor = descriptor;
<span id='Matching-DescriptorData-property-histograms'>        /** The histograms composing the descriptors
</span>         * @property {Array} histograms
         */
        this.histograms = h;
<span id='Matching-DescriptorData-property-nBin'>        /** Number of bins used to build the histograms
</span>         * @property {Number} nBin 
         */
        this.nBin = nBin;
<span id='Matching-DescriptorData-property-nSec'>        /** Number of histograms.
</span>         * @property {Number} nSec
         */
        this.nSector = nSec;
<span id='Matching-DescriptorData-property-data'>        /** The concatenation of the histograms.
</span>         * @property {Array} data
         */
        this.data = data;
<span id='Matching-DescriptorData-property-pps'>        /** For each sector, the number of points used to build the 
</span>         * corresponding histogram. 
         * @property {Array} pps
         */
        this.pps = new Float32Array(nSec);
<span id='Matching-DescriptorData-property-sum'>        /** For each sector, the sum of the weights used to build the 
</span>         * corresponding histogram. 
         * @property {Array} sum
         */
        this.sum = new Float32Array(nSec);
    }

    DescriptorData.prototype = {
<span id='Matching-DescriptorData-method-extractModes'>        /** Extract modes from descriptor histograms. 
</span>         * @chainable
         */
        extractModes: function () {
            var h = this.histograms;
            var sum = this.sum;
            var pps = this.pps;
            var i, ei;
            this.modes = [];
            for (i = 0, ei = h.length; i &lt; ei; i++) {
                var l = sum[i] / pps[i];
                this.modes[i] = extractModes(h[i], true, 0, pps[i], l, l * l);
            }
            return this;
        },
<span id='Matching-DescriptorData-method-modesToHistograms'>        /** Create histograms from modes. 
</span>         * @chainable
         */
        modesToHistograms: function () {
            var hs = this.histograms, h;

            var ms = this.modes, m;
            var nBin = this.nBin;
            var i, j, ei, ej;

            var round = Math.round;
            for (i = 0, ei = h.length; i &lt; ei; i++) {
                h = hs[i];
                for (j = 0, ej = nBin; j &lt; ej; j++) {
                    h[j] = 0;
                }
                m = ms[i];
                for (j = 0, ej = m.length; j &lt; ej; j++) {
                    h[round(m[j].phase * nBin)] = m[j].norm;
                }
            }

            return this;
        },
<span id='Matching-DescriptorData-method-normalizeModes'>        /** Normalize modes by the histograms sum. 
</span>         * @chainable
         */
        normalizeModes: function () {
            var modes = this.modes;
            var i, j, ei, ej, sum;
            /*
             for (i = 0, sum = 0, ei = modes.length; i &lt; ei; i++) {
             for (j = 0, ej = modes[i].length; j &lt; ej; j++) {
             sum += modes[i][j].norm;
             }
             }
             */
            var sums = this.sum;
            for (i = 0, sum = 0, ei = sums.length; i &lt; ei; i++) {
                sum += sums[i];
            }
            sum = (sum &gt; 0) ? 1 / sum : 0;
            for (i = 0, ei = modes.length; i &lt; ei; i++) {
                for (j = 0, ej = modes[i].length; j &lt; ej; j++) {
                    modes[i][j].norm *= sum;
                }
            }
            return this;
        },
<span id='Matching-DescriptorData-method-processModes'>        /** Quantify modes position and weight. 
</span>         * @chainable
         */
        processModes: function () {
            var modes = this.modes;
            var i, j, ei, ej;
            for (i = 0, ei = modes.length; i &lt; ei; i++) {
                if (modes[i].length &gt; 1) {
                    modes[i].slice(0, 1);
                }

                for (j = 0, ej = modes[i].length; j &lt; ej; j++) {
                    var p = modes[i][j].phase;
                    var n = modes[i][j].norm;

                    var N = 4, M = 0.2;
                    p  = Math.floor(p * N) / N;

                    n = Math.floor(n * N / M) + 1;
                    n = (n &gt;= N ? N : n) / N;

                    modes[i][j].phase = p;
                    modes[i][j].norm = n;
                }
            }
            return this;
        },
<span id='Matching-DescriptorData-method-normalizeHistograms'>        /** Normalize histograms such that the descriptor sums up to one.
</span>         * @chainable
         */
        normalizeHistograms: function () {
            var h = this.histograms;
            var pps = this.pps;
            var i, j, ei, ej, sum;

            // Normalization w.r.t pps
            for (i = 0, ei = h.length, sum = 0; i &lt; ei; i++) {
                if (pps[i] !== 0) {
                    for (j = 0, ej = h[i].length; j &lt; ej; j++) {
                        h[i][j] /= pps[i];
                        sum += h[i][j];
                    }
                }
            }

            // Descriptor must sum up to 1
            sum = (sum &gt; 0) ? 1 / sum : 0;
            for (i = 0; i &lt; ei; i++) {
                for (j = 0, ej = h[i].length; j &lt; ej; j++) {
                    h[i][j] *= sum;
                }
            }
            return this;
        },
<span id='Matching-DescriptorData-method-cumulHistograms'>        /** 
</span>         Compute the cumulative histograms. 
         This is used to decrease 
         the time needed to compute CEMD distances between histograms.
         @chainable
         */
        cumulHistograms: function () {
            var h = this.histograms, nBin = this.nBin, nSec = this.nSector;
            this.cumulatedData = new Float32Array(nBin * nSec);
            this.cumulatedHistograms = [];
            var hc = this.cumulatedHistograms;
            var i, j, ej;
            for (i = 0; i &lt; nSec; i++) {
                hc[i] = this.cumulatedData.subarray(i * nBin, (i + 1) * nBin);
                hc[i][0] = h[i][0];
                for (j = 1, ej = hc[i].length; j &lt; ej; j++) {
                    hc[i][j] = hc[i][j - 1] + h[i][j];
                }
                for (j = 1, ej = hc[i].length; j &lt; ej; j++) {
                    hc[i][j] = hc[i][j - 1] + h[i][j];
                }
            }
            return this;
        },
<span id='Matching-DescriptorData-method-toString'>        /** Convert descriptor histograms to `String`. Designed for export
</span>         * purposes.
         * @return {String} 
         */
        toString: function () {
            var str = &quot;&quot;;
            var h = this.histograms;
            var i, j, ei, ej;

            // Normalization w.r.t pps
            for (i = 0, ei = h.length; i &lt; ei; i++) {
                for (j = 0, ej = h[i].length; j &lt; ej; j++) {
                    str += h[i][j] + &quot; &quot;;
                }
                str += &quot;\n&quot;;
            }
            return str;
        }
    };

    global.DescriptorData = DescriptorData;

})(Matching);
</pre>
</body>
</html>
