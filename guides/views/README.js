Ext.data.JsonP.views({"guide":"<h1 id='views-section-the-matrixview-class'>The MatrixView class</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ol>\n<li><a href='#!/guide/views-section-creating-a-view'>Creating a view</a></li>\n<li><a href='#!/guide/views-section-getting-an-iterator-to-scan-the-view'>Getting an iterator to scan the view</a></li>\n<li><a href='#!/guide/views-section-the-select-operator'>The select operator</a></li>\n<li><a href='#!/guide/views-section-creating-2d-and-nd-views'>Creating 2D and ND views</a></li>\n<li><a href='#!/guide/views-section-two-types-of-iterators'>Two types of Iterators</a></li>\n<li><a href='#!/guide/views-section-using-the-iterators-%3A-simplest-approaches'>Using the iterators : simplest approaches</a></li>\n</ol>\n</div>\n\n<p>Remember that a <code>MatrixView</code> Object describes how a one dimensionnal array must be interpreted. That is it describes the order to use to read the data when it corresponds to a multidimensional array.\nFor instance, the array <code>['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']</code> can be thought either as a vector column vector of size <code>9x1</code>, a row vector of size <code>1x9</code> or as a <code>3x3</code> matrix :</p>\n\n<pre><code>// Data seen as a row vector (1x9)\n'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i'\n\n// Data seen as a 3x3 matrix in column-major order\n'a' 'd' 'g'\n'b' 'e' 'h'\n'c' 'f' 'i'\n\n// Data seen as a 3x3 matrix in row-major order\n'a' 'b' 'c'\n'd' 'e' 'f'\n'g' 'h' 'i'\n</code></pre>\n\n<p><strong>As a convention we will consider in this tutorial the column major-order, since it is the one used in most of the numercial software. But since it is only a convention, you can decide to use the one fitting the best your wishes. In addition, The <code>MatrixView</code> class provides tools to change the convention.</strong></p>\n\n<p>The <code>MatrixView</code> class aims to describe how data coming from a unidimensional array must be read. If allow to apply very easily many operations on the elements :</p>\n\n<ul>\n<li>in a given order,</li>\n<li>colum by column,</li>\n<li>row by row,</li>\n<li>one over two,</li>\n<li>in a reverse order, etc.</li>\n</ul>\n\n\n<p>An important thing on the views is that they do not modify the data, they only allow to read them in a given order.</p>\n\n<h2 id='views-section-creating-a-view'>Creating a view</h2>\n\n<p>For instance, we can consider the following example</p>\n\n<pre><code>// Constructing the data\nvar data = ['a', 'b', 'c', 'd', 'e'];\n\n// First we need to create a View\nvar view = new MatrixView([data.length]);\n</code></pre>\n\n<p>Here we use an array of string, in order to avoid confusion between indices and data, but any kind of objects and in can be used. For instance you can use it to easily make a speadsheet program.</p>\n\n<h2 id='views-section-getting-an-iterator-to-scan-the-view'>Getting an iterator to scan the view</h2>\n\n<p>We can then define an iterator on this view in order to go through the data:</p>\n\n<pre><code>// Iterator to scan the view\nvar iterator =  view.getIterator(0);\n\n// Shortcut to iterator methods\nvar it = iterator.iterator, b = iterator.begin, e = iterator.end;\n\n// Go through the data\nfor (var i = b(), ie = e(); i !== ie; i = it()) {\n    console.log(i, data[i]);\n}\n</code></pre>\n\n<p><strong>Note that the use of the iterator will be explain in details in a following part of this tutorial. For now, we will only consider it as a tool to display the results of the view manipulations.</strong></p>\n\n<p>When we run this code, the iterator will scan the data. In the following, we will how to modify the view in order to scan the data in different ways.</p>\n\n<h1 id='views-section-some-basic-manipulations-on-views'>Some basic manipulations on views</h1>\n\n<h2 id='views-section-the-select-operator'>The select operator</h2>\n\n<p>This operator is the most useful operator to modify the way the data are readed.\nIt is the equivalent of the operator <code>()</code> in [Matlab][1].\nIn order to have a working example, the view modification has to be inserted between the view declaration and the the iterator example.</p>\n\n<h3 id='views-section-select-one-value'>Select one value</h3>\n\n<p>The <code>select</code> can be used to select only one value.\nHere, we want to select the value <code>'c'</code>, this can be done like this</p>\n\n<pre><code>// Select only one value\nview.select(2);\n</code></pre>\n\n<p>The iterator will only scan the second value of the data variable.\nWe give here the complete code obtained by the concatenation of the 3 examples:</p>\n\n<pre><code>// Constructing the data\nvar data = ['a', 'b', 'c', 'd', 'e'];\n\n// First we need to create a View\nvar view = new MatrixView([data.length]);\n\n\n// Select only one value\nview.select(2);\n\n\n// Iterator to scan the view\nvar iterator =  view.getIterator(0);\n\n// Shortcut to iterator methods\nvar it = iterator.iterator, b = iterator.begin, e = iterator.end;\n\n// Go through the data\nfor (var i = b(), ie = e(); i !== ie; i = it()) {\n    console.log(i, data[i]);\n}\n</code></pre>\n\n<p>This can look at a very complicated way to realize this operation, but the next examples will we demonstrate the flexibility allowed by the <code>MatrixView</code> class.</p>\n\n<h3 id='views-section-select-a-subpart-of-the-data'>Select a subpart of the data</h3>\n\n<p>We may wish to select only a part of the previous data such that removing selecting only the 3 last components of the variable <code>data</code>. This can be done like this</p>\n\n<pre><code>// Select a subpart of the data\nview.select([2, -1]);\n</code></pre>\n\n<p>Here the first argument of the <code>select</code> method is an array made with two integers. The first (<code>2</code>) gives the starting point of the selection and the last (<code>-1</code>) indicates the end point. Note that the negative values are used to indicate indices from the end.\nBy this way, the iterator we scan the values <code>['c', 'd', 'e']</code> of the data.</p>\n\n<h3 id='views-section-select-one-over-two-values'>Select one over two values</h3>\n\n<p>Now, we are looking to downsampling the data by taking one over two values this can also be done by using the <code>select</code> method :</p>\n\n<pre><code>// Select a subpart of the data\nview.select([0, 2, -1]);\n</code></pre>\n\n<p>Here, the first (<code>0</code>) and the end (<code>-1</code>) still indicate the first and the last values to consider but between we inserted a step value giving the increment between two selected values.\nThe iterator will therefore scan the values <code>['a', 'c', 'e']</code>.</p>\n\n<h3 id='views-section-reverse-the-selection'>Reverse the selection</h3>\n\n<p>Here we are looking to scan the data in a reversed order. given the previous examples this can be easily done with the following:</p>\n\n<pre><code>// Select a subpart of the data\nview.select([-1, -1, 0]);\n</code></pre>\n\n<p>This states the we start from the last indice (<code>-1</code>), with a negative unit step (<code>-1</code>) and we will finish on the first indice (<code>0</code>). As a result, the iteror will return all the values in <code>data</code> but in a reverse order (<code>['e', 'd', 'c', 'b', 'a']</code>).</p>\n\n<h3 id='views-section-reordering-the-data-in-a-given-order'>Reordering the data in a given order</h3>\n\n<p>Reordering completely the variable <code>data</code> is also possible with the <code>select</code> method.\nWe can give directly the order we want :</p>\n\n<pre><code>// Rearranging the data\nview.select([[4, 4, 3, 3, 1, 0, 2]]);\n</code></pre>\n\n<p>Note that to provide directly the order of the data we use a 2D Array (<code>[[]]</code>).\nHere the iterator will return the values (<code>['e', 'e', 'd', 'd', 'b', 'a', 'c']</code>).</p>\n\n<h2 id='views-section-creating-2d-and-nd-views'>Creating 2D and ND views</h2>\n\n<p>Considering the array from the previous example, we need first to create a view :</p>\n\n<pre><code>// Constructing the data\nvar data = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'];\n\n// First we need to create a View\nvar view = new MatrixView([3, 3]);\n</code></pre>\n\n<p>From now, the view will consider that the elements of the array <code>data</code> corresponds to the following structure, which will be called the canonical view :</p>\n\n<pre><code>'a' 'd' 'g'\n'b' 'e' 'h'\n'c' 'f' 'i'\n</code></pre>\n\n<p>The <code>select</code> method can be used as well with this view. The first argument will give the selection on the first dimention (the columns) and the second will give the selection on the second dimentsion (the rows).</p>\n\n<h3 id='views-section-select-a-given-column-or-row'>Select a given column or row</h3>\n\n<p>You can select a given row using one of these instructions :</p>\n\n<pre><code>// Different ways to select one column \nview.select([], 1);\nview.select([], [1]);\nview.select([], [[1]]);\n</code></pre>\n\n<p>These three options will returned the following result.</p>\n\n<pre><code>'d'\n'e'\n'f'\n</code></pre>\n\n<h3 id='views-section-reverse-the-column-order'>Reverse the column order</h3>\n\n<p>In order to reverse the order of the columns we can reverse the rows. Indeed, reversing the data on each row will rearrange the columns:</p>\n\n<pre><code>// Reversing the data on each row \nview.select([], [-1, -1, 0]);\n</code></pre>\n\n<p>Note that the first argument <code>[]</code> indicate we do not want to modify the selection on the columns.\nNow the view will see the data like this:</p>\n\n<pre><code>'g' 'd' 'a'\n'h' 'e' 'b'\n'i' 'f' 'c'\n</code></pre>\n\n<p>The use of the <code>select</code> method on ND views is straightforward. Each argument correspond the selection on the corresponding dimension (first argument first dimension, ...).</p>\n\n<h3 id='views-section-repeating-the-data'>Repeating the data</h3>\n\n<pre><code>// Repeting the data 2 times on each dimension \nview.select([[0, 1, 2, 0, 1, 2]], [[0, 1, 2, 0, 1, 2]]);\n</code></pre>\n\n<p>As a result the view is now interpreting the data like this</p>\n\n<pre><code>'a' 'd' 'g'  'a' 'd' 'g' \n'b' 'e' 'h'  'b' 'e' 'h' \n'c' 'f' 'i'  'c' 'f' 'i'\n\n'a' 'd' 'g'  'a' 'd' 'g' \n'b' 'e' 'h'  'b' 'e' 'h' \n'c' 'f' 'i'  'c' 'f' 'i'\n</code></pre>\n\n<p><strong>Note that since the data are not explicitely duplicated, this operation is done with at a very low memory cost. This is especially true when the initial datas are already large.</strong></p>\n\n<h3 id='views-section-dimension-permutation'>Dimension permutation</h3>\n\n<p>The MatrixView also allows to modify the order in which the dimensions are read.</p>\n\n<pre><code>// Permuting the dimensions\nview.permute([1, 0]);\n</code></pre>\n\n<p>As a result, we will have the data transposed.</p>\n\n<pre><code>'a' 'b' 'c'\n'd' 'e' 'f'\n'g' 'h' 'i'\n</code></pre>\n\n<p>This function is a generalisation to the transposition operation to ND views.\nYou can check the followings functions:</p>\n\n<ul>\n<li><a href=\"#!/api/MatrixView-method-permute\" rel=\"MatrixView-method-permute\" class=\"docClass\">permute</a>,</li>\n<li><a href=\"#!/api/MatrixView-method-ipermute\" rel=\"MatrixView-method-ipermute\" class=\"docClass\">ipermute</a>,</li>\n<li><a href=\"#!/api/MatrixView-method-rot90\" rel=\"MatrixView-method-rot90\" class=\"docClass\">rot90</a>.</li>\n</ul>\n\n\n<h1 id='views-section-the-iterators'>The iterators</h1>\n\n<p>We see how to change the way a <code>MatrixView</code> allow to controlthe in which order the datas are read. But now how do we access to the data ?\nThe iterators are the tools for that. An Iterator is designed to go element by element through the whole data (for instance all he elements of a matrix), while a subiterator is designed to go through the element of a part of the data (for instance a row or a column of a matrix).</p>\n\n<h2 id='views-section-two-types-of-iterators'>Two types of Iterators</h2>\n\n<h3 id='views-section-full-iterators'>Full Iterators</h3>\n\n<p>An iterator allow to go through different dimensions automatically ; it has the following methods:</p>\n\n<ul>\n<li><code>iterator</code> : function used to iterate on the view. It returns the new indice ;</li>\n<li><code>begin</code> : function returning the first indice ;</li>\n<li><code>end</code> : function returning the value reached when every indices had been visited ;</li>\n<li><code>isEnd</code> function returning true if  every indices had been visited ;</li>\n<li><code>getPosition</code> return an array containing the position of the iterator on every dimension.</li>\n</ul>\n\n\n<p>An iterator correspondonding to a given view can be obtained by this way:</p>\n\n<pre><code>// Get an iterator\nvar iterator = view.getIterator(dimension);\n</code></pre>\n\n<p>The parameter <code>dimension</code> allow to control on which dimensions the iterator will work.\nFor instance if you have a 5D view, and dimension is zeros, the iterator will works on the five dimensions. So, you will not have the possibility to apply an operation to each column or to each row.\nTo get this possibility, you need set the <code>dimension</code> parameter on the lowest dimension not requiring any special action.\nThen you need to get a specific Iterator (a <code>SubIterator</code>) on the dimensions you have to control.</p>\n\n<h3 id='views-section-subiterators'>SubIterators</h3>\n\n<p>A subiterator is an object allowing to go through only one dimension. It has the same methods than an iterator but with the following differences:</p>\n\n<ul>\n<li><code>begin</code> : function returning the first indice <strong>but can take an offset as a parameter</strong> ;</li>\n<li><code>getPosition</code>: function returning a value correponding to the current position of the iterator <strong>not an array</strong>.</li>\n<li><code>getIndex</code>: function returning the current values of the iterator (the last returned by the <code>iterator</code> method).</li>\n</ul>\n\n\n<h2 id='views-section-using-the-iterators-%3A-simplest-approaches'>Using the iterators : simplest approaches</h2>\n\n<p>Here, we give some exemples on how to used iterators. Iterators and subiterators are embedded classes and cannot be created directly with the <code>new</code> operator.\nTherefore we need to create a view first before using them.\nAs seen above, this can be done by the following snippet:</p>\n\n<pre><code>// First we need to create a View\nvar view = new MatrixView([2,3,2]);\n</code></pre>\n\n<p>Remember that a <code>MatrixView</code> Object describes the order used to read a unidimensional <code>Array</code> when it is seen as a multidimensional array.</p>\n\n<h3 id='views-section-simplest-way-to-scan-the-view'>Simplest way to scan the view</h3>\n\n<pre><code>// First we need to create a View\nvar view = new MatrixView([2,3,2]);\n\n// Iterator to scan the view\nvar iterator =  view.getIterator(0);\n\n// Shortcut to iterator methods\nvar it = iterator.iterator, b = iterator.begin, e = iterator.end;\n\n// Go through the data\nfor (var i = b(), ie = e(); i !== ie; i = it()) {\n    // Iterators position\n    var pos = iterator.getPosition();\n    console.log('indice:', i, 'position:', pos);\n}\n</code></pre>\n\n<h3 id='views-section-simplest-way-with-control-on-dimension-0'>Simplest way with control on dimension 0</h3>\n\n<pre><code>// First we need to create a View\nvar view = new MatrixView([2,3,2]);\n\n// Iterator to scan the view on dimension greater than 0\nvar iterator = view.getIterator(1);\nvar it = iterator.iterator, b = iterator.begin, e = iterator.end;\n\n// SubIterator to scan the view with control on dimension 0\nvar iteratory = view.getSubIterator(0);\nvar ity = iteratory.iterator, by = iteratory.begin, endy = iteratory.end;\n\nfor (var i = b(), ei = e(); i !== ei; i = it()) {\n    for (var y = by(i), ey = endy(); y !== ey; y = ity()) {\n        // Iterators position\n        var posy = iteratory.getPosition(), pos = iterator.getPosition();\n        console.log('indice:', y, 'position:', posy, pos);\n    }\n}\n</code></pre>\n\n<p>We can observe on the second loop that we initialize the iterator with the <code>i</code> varable.</p>\n\n<h3 id='views-section-simplest-way-with-control-on-dimension-0-and-1'>Simplest way with control on dimension 0 and 1</h3>\n\n<pre><code>// First we need to create a 3D View \nvar view = new MatrixView([2,3,2]);\n\n// Iterator to scan the view on dimension greater than 1 (here the dimension 2)\nvar iterator = view.getIterator(2);\nvar it = iterator.iterator, b = iterator.begin, e = iterator.end;\n\n// SubIterator to scan the view with control on dimension 1\nvar iteratorx = view.getSubIterator(1);\nvar itx = iteratorx.iterator, bx = iteratorx.begin, endx = iteratorx.end;\n\n// SubIterator to scan the view with control on dimension 0\nvar iteratory = view.getSubIterator(0);\nvar ity = iteratory.iterator, by = iteratory.begin, endy = iteratory.end;\n\nfor (var i = b(), ei = e(); i !== ei; i = it()) {\n    for (var x = bx(i), ex = endx(); x !== ex; x = itx()) {\n        for (var y = by(x), ey = endy(); y !== ey; y = ity()) {\n             // Iterators position\n             var posy = iteratory.getPosition(),\n                 posx = iteratorx.getPosition(),\n                 pos = iterator.getPosition();\n             console.log('indice:', y, 'position:', posy, posx, pos);\n        }\n    }\n}\n</code></pre>\n\n<!--\n## Using the iterators : more efficient approaches\n\n### Same but more efficient way\n\n    // Scaning the from the second dimension (dim = 1)\n    var i, it  = this.getIterator(1), b = it.begin, e = it.isEnd;\n    // First x value, end x value\n    var x, f = it.getFirst(0), l = it.getEnd(0);\n    // Iterators position\n    var pos = it.getPosition();\n\n    if (this.isIndicesIndexed(0)) {\n        // Steps between 2 x values\n        var s, steps = it.getSteps(0);\n        for (i = b(); !e(); i = it()) {\n            for (s = 0, x = i + f; x !== l; x += steps[++s]) {\n                console.log('indice:', x, 'position:', s, pos);\n            }\n        }\n    } else {\n        // Step between 2 x values\n        var n, d = it.getStep(0);\n        for (i = b(); !e(); i = it()) {\n            for (x = i + f, n = i + l; x !== n; x += d) {\n                console.log('indice:', x, 'position:', (x - i) / d, pos);\n            }\n        }\n    }\n\n### With control on the 2 first dimensions\n\n    @example\n    // Scaning the from the second dimension (dim = 1)\n    var i, ie, it  = this.getIterator(2), b = it.begin, e = it.end;\n    // First value, step between 2 values, end value\n    var x, xe, itx = it.getSubIterator(1), bx = itx.begin, ex = itx.end;\n    var y, fy = it.getFirst(0), ly = it.getEnd(0);\n    // Iterators position\n    var posx = itx.getPosition(), pos = it.getPosition();\n\n    if (this.isIndicesIndexed(0)) {\n        var sy, ySteps = it.getSteps(0);\n        for (i = b(), ie = e(); i !== ie; i = it()) {\n            for (x = bx(i), xe = ex(); x !== xe; x = itx()) {\n                for (sy = 0, y = x + fy; y !== ly; y += ySteps[++sy]) {\n                    console.log('indice:', y, 'position:', sy, posx, pos);\n                }\n            }\n        }\n    } else {\n        var ny, dy = it.getStep(0);\n        for (i = b(), ie = e(); i !== ie; i = it()) {\n            for (x = bx(i), xe = ex(); x !== xe; x = itx()) {\n                for (y = x + fy, ny = x + ly; y !== ny; y += dy) {\n                    console.log('indice:', y,  'position:', (y - x) / dy, posx, pos);\n                }\n            }\n        }\n    }\n\n### The extremist way\n\n    @example\n    // Scaning the from the second dimension (dim = 1)\n    var i, ie, it  = this.getIterator(2), b = it.begin, e = it.end;\n    // First value, step between 2 values, end value\n    var x, sx, xSteps, dx, nx, fx = it.getFirst(1), lx = it.getEnd(1);\n    var y, sy, ySteps, dy, ny, fy = it.getFirst(0), ly = it.getEnd(0);\n    // Iterators position\n    var pos = it.getPosition();\n\n    if (this.isIndicesIndexed(1)) {\n        xSteps = it.getSteps(1);\n        if (this.isIndicesIndexed(0)) {\n            ySteps = it.getSteps(0);\n            for (i = b(), ie = e(); i !== ie; i = it()) {\n                for (sx = 0, x = i + fx; x !== lx; x += xSteps[++sx]) {\n                    for (sy = 0, y = x + fy; y !== ly; y += ySteps[++sy]) {\n                        console.log('indice:', y, 'position:', sy, sx, pos);\n                    }\n                }\n            }\n        } else {\n            dy = it.getStep(0);\n            for (i = b(), ie = e(); i !== ie; i = it()) {\n                for (sx = 0, x = i + fx; x !== lx; x += xSteps[++sx]) {\n                    for (y = x + fy, ny = x + ly; y !== ny; y += dy) {\n                        console.log('indice:', y, 'position:', (y - x) / dy, sx, pos);\n                    }\n                }\n            }\n        }\n    } else {\n        dx = it.getStep(1);\n        if (this.isIndicesIndexed(0)) {\n            ySteps = it.getSteps(0);\n            for (i = b(), ie = e(); i !== ie; i = it()) {\n                for (x = i + fx, nx = i + lx; x !== nx; x += dx) {\n                    for (sy = 0, y = x + fy; y !== ly; y += ySteps[++sy]) {\n                        console.log('indice:', y, 'position:', sy, (x - i) / dx, pos);\n                    }\n                }\n            }\n        } else {\n            dy = it.getStep(0);\n            for (i = b(), ie = e(); i !== ie; i = it()) {\n                for (x = i + fx, nx = i + lx; x !== nx; x += dx) {\n                    for (y = x + fy, ny = x + ly; y !== ny; y += dy) {\n                        console.log('indice:', y, 'position:', (y - x) / dy, (x - i) / dx, pos);\n                    }\n                }\n            }\n        }\n    }\n\n-->\n\n\n<h1 id='views-section-extracting-the-data'>Extracting the data</h1>\n","title":"The MatrixView class introduction"});